{"pages":[],"posts":[{"title":"算法与数据结构","text":"C++面向对象封装真正的面向对象的编程需要对象支持三种特性：封装、继承和多态性。 True object-orient programming requires objects to support three qualities: encapsulation, inheritance, and polymorphism. 继承多态常用算法动态规划最长回文子序列 123456789101112131415161718192021222324252627282930class Solution {public: static const int N=1010; int dp[N][N]; int longestPalindromeSubseq(string s) { int n=s.size(); for(int i=n-1;i&gt;=0;i--){ for(int j=i;j&lt;n;j++){ if(i==j){ dp[i][j]=1; continue; } if(i+1==j){ if(s[i]==s[j]) dp[i][j]=2; else dp[i][j]=1; continue; } int tmp=max(dp[i][j-1],dp[i+1][j]); if(s[i]==s[j]) dp[i][j]=max(tmp,2+dp[i+1][j-1]); else dp[i][j]=tmp; } } return dp[0][n-1]; }}; 最长递增子序列 123456789101112int lengthOfLIS(vector&lt;int&gt;&amp; nums) { int n=nums.size(); int ans=1; vector&lt;int&gt;dp(n,1); for(int i=1;i&lt;n;i++){ for(int j=0;j&lt;i;j++) if(nums[i]&gt;nums[j]) dp[i]=max(dp[i],dp[j]+1); ans=max(ans,dp[i]); } return ans; } 前缀和与差分前缀和与差分可快速计算出任意两个区间之间的和 //真题：2017_3 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int c,x,ans=0;int main(){ cin&gt;&gt;c&gt;&gt;x; vector&lt;int&gt;arr(c,0); vector&lt;int&gt;preSum(c,0); for(int i=0;i&lt;c;i++) cin&gt;&gt;arr[i]; preSum[0]=arr[0]; for(int i=1;i&lt;c;i++) preSum[i]=preSum[i-1]+arr[i]; for(int i=0;i&lt;c;i++){ for(int j=i;j&lt;c;j++){ int t; if(i==0) t=preSum[j]; else t=preSum[j]-preSum[i-1];//t表示arr[i]到arr[j]的所有数字的和(包括i和j) if(t&gt;=x) ans++; } } cout&lt;&lt;ans; return 0;} 递归加回溯N皇后 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;algorithm&gt; #include&lt;vector&gt;using namespace std;vector&lt;vector&lt;int&gt; &gt;ans;vector&lt;int&gt;path;//path[i]表示第i+1行的皇后所在列，整个path表示一种方案 bool col[100],Left[100],Right[100]; //初始值为false，表示没有放皇后 int n,res=0;;bool check(int c,int l,int r){//判断皇后是否能放在k行i列 return !col[c] &amp;&amp; !Left[l] &amp;&amp; !Right[r];}void dfs(int k){//皇后放在第k行的情况 if(k==n){ ans.push_back(path); res++; return; } //选路 for(int i=0;i&lt;n;i++){//(k,i)表示皇后放在第k行第i列 int c=i;//行 int l=k+i;//列 int r=n-(i-k+1);//右对角线 if(!check(c,l,r)) continue; col[c]=true; Left[l]=true; Right[r]=true; path.push_back(i+1); //递归 dfs(k+1); //回溯 col[c]=false; Left[l]=false; Right[r]=false; path.pop_back(); } }int main(){ cin&gt;&gt;n; dfs(0); sort(ans.begin(),ans.end()); for(int i=0;i&lt;3;i++){ for(int j=0;j&lt;n;j++){ cout&lt;&lt;ans[i][j]&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; } cout&lt;&lt;res; return 0;} 求第K小的数案例：求第 k 小的数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;ctime&gt;using namespace std;int partition(vector&lt;int&gt; &amp;arr, int low, int high) { int p=rand()%(high-low+1)+low; int pivot = arr[p]; /*下面操作使arr[low]换回来，防止出错*/ int tmp=arr[p]; arr[p]=arr[low]; arr[low]=tmp; while (low &lt; high) { /*从右边找小于基准的*/ while (low &lt; high &amp;&amp; arr[high] &gt;= pivot) high--; arr[low] = arr[high]; /*从左边找大于基准的*/ while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) low++; arr[high] = arr[low]; } arr[low] = pivot; return low;}int ans; //最终的元素小标void func(vector&lt;int&gt; &amp;arr, int left, int right, int k) { /*确定一个元素的最终位置：选取基准元素，将小的放左边，大的放右边*/ int t = partition(arr, left, right); /*看基准下标和k的关系*/ if (t == k){ ans = t; return; } else if (t &gt; k) func(arr, left, t - 1, k); else func(arr, t + 1, right, k);}int main() { srand((unsigned)time(NULL)); int n, k, x; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; arr(n); for (int i = 0; i&lt; n; i++){ scanf(&quot;%d&quot;,&amp;x); //写cin就超时 arr[i]=x; } func(arr,0,n-1,k); cout&lt;&lt;arr[ans]; return 0;} 排序快速排序（取随机数优化了）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include &lt;ctime&gt; //取随机种子需要这个头文件using namespace std;int arr[100001];int partition(int arr[], int low, int high) { int p=rand()%(high-low+1)+low; //从下标low到high中取随机数 int pivot = arr[p]; /*下面操作使arr[low]换回来，防止出错*/ int tmp=arr[p]; arr[p]=arr[low]; arr[low]=tmp; while (low &lt; high) { /*从右边找小于基准的*/ while (low &lt; high &amp;&amp; arr[high] &gt;= pivot) high--; arr[low] = arr[high]; /*从左边找大于基准的*/ while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) low++; arr[high] = arr[low]; } arr[low] = pivot; return low;}void quickSort(int arr[], int low, int high) { if (low &gt;= high) return; int pivotpos = partition(arr, low, high); quickSort(arr, low, pivotpos - 1); quickSort(arr, pivotpos + 1, high);}int main() { srand((unsigned)time(NULL)); //取随机种子，取随机数必须要写的 int n; scanf(&quot;%d&quot;,&amp;n); for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;,&amp;arr[i]); quickSort(arr, 0, n - 1); for (int i = 0; i &lt; n; i++) printf(&quot;%d &quot;,arr[i]); return 0;} 注：随机打乱数据，防止因为数据基本有序或大量重复元素导致时间复杂度为O(n2) 直接插入排序堆排序STL用法lower_bound和upper_boundlower_bound(first,last,val)是返回第一个值大于等于val的元素的位置（指针或迭代器），可以减去开头指针和开头迭代器来获得元素下标；upper_bound(first,last,val)是返回第一个值大于val的元素的位置（指针或迭代器），可以减去开头指针和开头迭代器来获得元素下标。如果没有就返回考研插入val的位置 注意：数组或容器里元素必须递增有序，因为底层用的是二分查找！ 例题 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt; using namespace std;int m,n;int main(){ cin&gt;&gt;m&gt;&gt;n; long long ans=0; vector&lt;int&gt;line(m);//分数线 vector&lt;int&gt;score(n);//同学估的分 for(int i=0;i&lt;m;i++) cin&gt;&gt;line[i]; for(int i=0;i&lt;n;i++) cin&gt;&gt;score[i]; sort(line.begin(),line.end()); for(int i=0;i&lt;n;i++){ //pos表示第一个大于等于score[i]的元素下标 int pos=lower_bound(line.begin(),line.end(),score[i])-line.begin(); if(pos==0) ans+=abs(score[i]-line[0]); else if(pos==m) ans+=abs(score[i]-line[m-1]); else ans+=min(abs(score[i]-line[pos]),abs(score[i]-line[pos-1])); } cout&lt;&lt;ans; return 0; } maphttps://www.luogu.com.cn/problem/P1125#submit 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;//是否是质数bool isPrime(int n){ if(n&lt;2) return false; for(int i=2;i*i&lt;=n;i++){ if(n%i==0) return false; } return true;} int main(){ int maxn=0,minn=110; string s; cin&gt;&gt;s; map&lt;char,int&gt;mp;//map是自动按照key值排序的 for(int i=0;i&lt;s.size();i++) mp[s[i]]++; //中括号 for(map&lt;char,int&gt;::iterator it=mp.begin();it!=mp.end();it++){ maxn=max(maxn,it-&gt;second);//怎么输出key指向的value minn=min(minn,(*it).second); } int t=maxn-minn; if(isPrime(t)) cout&lt;&lt;&quot;Lucky Word&quot;&lt;&lt;endl&lt;&lt;t; else cout&lt;&lt;&quot;No Answer&quot;&lt;&lt;endl&lt;&lt;0; return 0; } sort自定义排序案例：奖学金 C++98标准写法 cmp函数中必须加const,否则会报错！！！ 注意：自定义比较函数的参数最好加引用，否则会因为需要创建大量副本而导致程序超时 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;struct stu { int sum, chinese, id; stu(int s, int c, int i) { sum = s; chinese = c; id = i; }};/*定义什么情况下A排在B前面（只考虑小于不考虑相等和大于）*/bool cmp(const stu &amp;A,const stu &amp;B) {//必须加const，否则会报错 if (A.sum &gt; B.sum) return true; if (A.sum == B.sum &amp;&amp; A.chinese &gt; B.chinese) return true; if (A.sum == B.sum &amp;&amp; A.chinese == B.chinese &amp;&amp; A.id &lt; B.id) return true; return false;}int main() { int n; cin &gt;&gt; n; int a, b, c; vector&lt;stu&gt; arr; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; arr.push_back(stu(a + b + c, a, i + 1)); } sort(arr.begin(), arr.end(), cmp); for (int i = 0; i &lt; 5; i++) { cout &lt;&lt; arr[i].id &lt;&lt; &quot; &quot; &lt;&lt; arr[i].sum&lt;&lt;endl; }} Lambda表达式写法 123456789sort(arr.begin(), arr.end(), [](stu &amp;A, stu &amp;B) { if (A.sum &gt; B.sum) return true; if (A.sum == B.sum &amp;&amp; A.chinese &gt; B.chinese) return true; if (A.sum == B.sum &amp;&amp; A.chinese == B.chinese &amp;&amp; A.id &lt; B.id) return true; return false;}); vector构建二维动态数组案例：烤鸡调料 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int sup[10]; //每种配料的数量int n;vector&lt;vector&lt;int&gt;&gt;ans; //二维vector/*选择第第k种配料的数量*/void f(int k){ #include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt;arr;//存最后的二维数组vector&lt;int&gt;num(10);//每种调料放多少int n,ansCount=0;/*在num[k]填数*/void func(int k){ /*终止条件*/ if(k==10){ int sum=0; for(int i=0;i&lt;10;i++) sum+=num[i]; if(sum==n){ arr.push_back(num); ansCount++; } return; } /*递归主体*/ num[k]=1; /*当前，当前节点值可能是1*/ func(k+1); /*后序*/ num[k]=2; /*也可能是2*/ func(k+1); num[k]=3; /*也可能是3*/ func(k+1);}int main(){ cin&gt;&gt;n; func(0); cout&lt;&lt;ansCount&lt;&lt;endl; for(int i=0;i&lt;ansCount;i++){ for(int j=0;j&lt;10;j++) cout&lt;&lt;arr[i][j]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; } return 0;} /*10种配料全部选完，看看是否符合要求*/ if(k==10){ int sum=0; for(int i=0;i&lt;10;i++){ sum+=sup[i]; } /*符合要求，把结果存起来*/ if(sum==n){ //把数填进二维动态数组中 vector&lt;int&gt;t; for(int i=0;i&lt;10;i++) t.push_back(sup[i]); ans.push_back(t); } return; } sup[k]=1; f(k+1); sup[k]=2; f(k+1); sup[k]=3; f(k+1); // for(int i=1;i&lt;=3;i++){// sup[k]=i;// f(k+1);// }}int main(){ cin&gt;&gt;n; f(0); cout&lt;&lt;ans.size()&lt;&lt;endl; for(int i=0;i&lt;ans.size();i++){ for(int j=0;j&lt;ans[i].size();j++){ cout&lt;&lt;ans[i][j]&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; } return 0;} 数学问题及其他高精度加法走楼梯 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;int n,len=1,arr[5010][1100];void cal(int k){/*计算第k台阶的方法数*/ for(int i=0;i&lt;len;i++) arr[k][i]=arr[k-1][i]+arr[k-2][i]; for(int i=0;i&lt;len;i++){ arr[k][i+1]+=arr[k][i]/10;//处理进位 arr[k][i]%=10;//存余，处理当前位 if(arr[k][len]!=0)//处理长度变化 len++; }}int main(){ cin&gt;&gt;n; arr[0][0]=1;//无意义，辅助链式计算 arr[1][0]=1; for(int i=2;i&lt;=n;i++) cal(i); for(int i=len-1;i&gt;=0;i--)//逆序输出 cout&lt;&lt;arr[n][i]; return 0;} 高精度加法和高精度乘法阶乘之和 1234567891011//不用高精度运算时int main(){ int n,sum=0,tmp=1; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ tmp*=i; sum+=tmp; } cout&lt;&lt;sum; return 0;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int sum[2000];//存储最终答案，初始为0int len_sum=0; int tmp[2000];//存储中间乘法结果，初始为1int len_tmp=1;int t[2000];//装高精度数i int len_t=0;//将数字倒序存储在数组中，返回数组长度int transfer(int n,int t[]){ //不用加引用，因为t[]本身就表示指向数组首地址的指针 if(n==0){ t[0]=0; return 1; } int i=0,len=0; while(n){ t[i++]=n%10; n/=10; len++; } return len;}//实现tmp=tmp*i:两个数组装高精度数，分别表示tmp和i,最终返回tmp数组的长度 int multiple(int a[],int lena,int b[],int lenb){ int lenc=lena+lenb; vector&lt;int&gt;c(lenc,0); for(int i=0;i&lt;lena;i++){ for(int j=0;j&lt;lenb;j++){ c[i+j]+=a[i]*b[j]; } } //进位存余 for(int i=0;i&lt;lenc;i++){ c[i+1]+=c[i]/10; c[i]%=10; } while(lenc&gt;1 &amp;&amp; c[lenc-1]==0) lenc--; //把结果存回a[] for(int i=0;i&lt;lenc;i++) a[i]=c[i]; return lenc; }void show(int a[],int len){ for(int i=0;i&lt;len;i++) cout&lt;&lt;a[len-1-i];} //实现sum=sum+tmp:两个数组装高精度数，分别表示sum和tmp，最终返回sum数组的长度 int add(int a[],int len1,int b[],int len2){ int n=max(len1,len2)+1; vector&lt;int&gt;c(n,0); //先加 for(int i=0;i&lt;n;i++) c[i]=a[i]+b[i]; //进位存余 for(int i=0;i&lt;n;i++){ c[i+1]+=c[i]/10; c[i]%=10; } while(n&gt;1 &amp;&amp; c[n-1]==0) n--; //把结果存回a[] for(int i=0;i&lt;n;i++) a[i]=c[i]; return n; }int main(){ int n; cin&gt;&gt;n; fill(sum,sum+2000,0); fill(tmp,tmp+2000,0); tmp[0]=1; for(int i=1;i&lt;=n;i++){ len_t=transfer(i,t); len_tmp=multiple(tmp,len_tmp,t,len_t);//tmp*=i len_sum=add(sum,len_sum,tmp,len_tmp);//sum+=tmp } for(int i=0;i&lt;len_sum;i++) cout&lt;&lt;sum[len_sum-1-i]; return 0;} 求最大公因数123456#include &lt;iostream&gt;using namespace std;int gcd(int a, int b) { return !b ? a : gcd(b, a % b);} 闰年判断123456//闰年：//能被4整除，不能被100整除。//能被4整除，也能被100整除。（能被400整除）bool isLeapYear(int n){ return n%400==0 || n%4==0 &amp;&amp; n%100!=0;} 排列数（递归+回溯）排列数有顺序，递归树可以有n个分支 1~9分成3个数，成比例 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;using namespace std;int num[9];bool flag[9];int a,b,c,count=0;/*选中或者不选num[k]*/void func(int k){ /*终止条件*/ if(k==9){ int p1=num[0]*100+num[1]*10+num[2]; int p2=num[3]*100+num[4]*10+num[5]; int p3=num[6]*100+num[7]*10+num[8]; int t=p1*b*c; if(t==p2*a*c &amp;&amp; t==p3*a*b){ cout&lt;&lt;p1&lt;&lt;&quot; &quot;&lt;&lt;p2&lt;&lt;&quot; &quot;&lt;&lt;p3&lt;&lt;endl; count++; } return; } /*递归主体*/ //num[k]=1;func(k+1); //num[k]=2;func(k+1);回溯 //…… //num[k]=9;func(k+1); for(int i=1;i&lt;10;i++){ if(!flag[i-1]){ num[k]=i; flag[i-1]=true; func(k+1); flag[i-1]=false; } }}int main(){ fill(flag,flag+9,false); cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; func(0); if(count==0) cout&lt;&lt;&quot;No!!!&quot;; return 0;} 组合数（递归+回溯）组合数没有顺序，递归树中每个结点只有两个分支：选或者不选 选数求和，和是否是素数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;int arr[20],num[20];//arr装输入的数，num装选中的数int ans=0,count=0,n,k;//ans表示最终答案,count表示选中的数的个数/*是否是素数*/bool isPrime(int n){ if(n&lt;=1) return false; for(int i=2;i&lt;n;i++){ if(n%i==0) return false; } return true;}/*递归选数：选或不选arr[t]*/void func(int t){/*终止条件*/ if(count==k){/*如果已经选中了k个数*/ int sum=0; for(int i=0;i&lt;k;i++) sum+=num[i]; if(isPrime(sum)) ans++; return; } if(t==n)/*如果t越界*/ return;/*递归主体*/ /*选arr[t]*/ num[count++]=arr[t]; func(t+1); count--; /*不选arr[t]*/ func(t+1);}int main(){ cin&gt;&gt;n&gt;&gt;k; for(int i=0;i&lt;n;i++) cin&gt;&gt;arr[i]; func(0); cout&lt;&lt;ans; return 0;} 组合的输出 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int n,r,count=0;vector&lt;int&gt;arr;//存放选中的数/*选不选k*/void func(int k){/*终止条件*/ /*已经选了r个数*/ if(count==r){ for(int i=0;i&lt;r;i++) printf(&quot;%3d&quot;,arr[i]); printf(&quot;\\n&quot;); return; } /*k越界*/ if(k==n+1) return;/*递归主体*/ /*选中k*/ arr.push_back(k); count++; func(k+1); arr.pop_back(); count--; /*不选k*/ func(k+1);}int main(){ cin&gt;&gt;n&gt;&gt;r; func(1); return 0;} 全排列全排列 注意： 序列必须已经从小到大排序好才能使用next_permutation next_permutation会自动去重(例如1,1,2) 1234567891011121314151617#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int arr[9];int main(){ int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) arr[i]=i+1; do{ for(int i=0;i&lt;n;i++) printf(&quot;%5d&quot;,arr[i]); printf(&quot;\\n&quot;); }while(next_permutation(arr,arr+n));} 火星人 123456789101112131415161718#include&lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int n,m; cin&gt;&gt;n&gt;&gt;m; vector&lt;int&gt;input(n); for(int i=0;i&lt;n;i++) cin&gt;&gt;input[i]; while(m--) next_permutation(input.begin(),input.end());//注意不能写input+n for(int i=0;i&lt;n;i++) cout&lt;&lt;input[i]&lt;&lt;&quot; &quot;; return 0;} 有价值的题目map,sort自定义排序南理工2015年真题第七题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;map&lt;int,int&gt;mp;//key表示数字，value表示出现次数 vector&lt;int&gt;arr; struct Num{ int data,cnt; Num(int a,int b){ data=a; cnt=b; } Num(){}};vector&lt;Num&gt;vec;int findPos(int k){ for(int i=0;i&lt;arr.size();i++){ if(arr[i]==k) return i; }}bool cmp(const Num &amp;A,const Num &amp;B){ int pos_a=findPos(A.data); int pos_b=findPos(B.data); return A.cnt&gt;B.cnt || A.cnt==B.cnt &amp;&amp; pos_a&lt;pos_b;}int main(){ while(true){ int x; cin&gt;&gt;x; if(x==-1) break; if(mp.find(x)==mp.end()) arr.push_back(x); mp[x]++; } for(int i=0;i&lt;arr.size();i++) cout&lt;&lt;arr[i]&lt;&lt;&quot;:&quot;&lt;&lt;mp[arr[i]]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; for(map&lt;int,int&gt;::iterator it=mp.begin();it!=mp.end();it++) vec.push_back(Num(it-&gt;first,it-&gt;second)); int n=vec.size(); sort(vec.begin(),vec.end(),cmp); for(int i=0;i&lt;n;i++) cout&lt;&lt;vec[i].data&lt;&lt;&quot;:&quot;&lt;&lt;vec[i].cnt&lt;&lt;&quot; &quot;; return 0; } sscanf和sprintf，使string类型输出int型口算练习题 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;char str[100],tmp[10];/*str存储最终的字符串*/int main(){ char ch;/*接收a,b,c，用于表示运算符*/ int n,p1,p2;/*p1,p2表示两个运算数*/ cin&gt;&gt;n; for(int i=0;i&lt;n;i++){ cin&gt;&gt;tmp;/*输入一串字符串*/ if(tmp[0]&gt;='a' &amp;&amp; tmp[0]&lt;='z'){ ch=tmp[0];/*如果是运算符,用ch接收*/ cin&gt;&gt;p1&gt;&gt;p2;/*并且继续输入数字*/ } else{ sscanf(tmp,&quot;%d&quot;,&amp;p1);/*如果是数字，就转换tmp[0]为int存到第一个数字p1中*/ cin&gt;&gt;p2;/*输入第二个数*/ } //memset(str,0,sizeof(str));/*清空str*/ if(ch=='a')/*如果输入了两个数，ch就是上个回合的ch不变，就保证了运算符一致*/ sprintf(str,&quot;%d+%d=%d&quot;,p1,p2,p1+p2); else if(ch=='b') sprintf(str,&quot;%d-%d=%d&quot;,p1,p2,p1-p2); else if(ch=='c') sprintf(str,&quot;%d*%d=%d&quot;,p1,p2,p1*p2); cout&lt;&lt;str&lt;&lt;endl&lt;&lt;strlen(str)&lt;&lt;endl; } return 0;} ASCII码中26个小写字母的循环输出后移n位后输出 123456789101112#include&lt;iostream&gt;using namespace std;int main(){ int n; string s; cin&gt;&gt;n&gt;&gt;s; for(int i=0;i&lt;s.size();i++){ s[i]=(s[i]+n-'a')%26+'a';//实现循环 cout&lt;&lt;s[i]; } return 0;} 贪心算法区间问题 注意：每次选区间右端点最小或者左端点最大的区间 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int n;struct Time { int a, b; Time(int x,int y){ a=x; b=y; } Time(){}};bool cmp(Time &amp;A, Time &amp;B) {//先选右端点最小的，按右端点从小到大排序 return A.b &lt; B.b;}int main() { cin &gt;&gt; n; vector&lt;Time&gt; arr(n); for (int i = 0; i &lt; n; i++) { int x,y; cin&gt;&gt;x&gt;&gt;y; Time t(x,y);//t是变量名，可以随便取 arr[i]=t; } sort(arr.begin(), arr.end(), cmp); int ans = 0; int rightEdge=0; //上一个被选中的区间的右端点 for (int i = 0; i &lt; n; i++) { if(arr[i].a&gt;=rightEdge){ rightEdge=arr[i].b; ans++; } } cout &lt;&lt; ans; return 0;} 求三个数的和出现次数最多是几次1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int s1,s2,s3,ans,maxTimes=0;; cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3; int t=s1+s2+s3; int arr[t+1]; fill(arr,arr+t+1,0); for(int i=1;i&lt;=s1;i++){ for(int j=1;j&lt;=s2;j++){ for(int k=1;k&lt;=s3;k++){ arr[i+j+k]++; if(arr[i+j+k]&gt;maxTimes){//&gt;而不是&gt;=，可以确保如果有好多个和出现频率一样最高，可以输出第一个频率最高的 maxTimes=arr[i+j+k];//在题目中就可以实现 ans=i+j+k; } } } } cout&lt;&lt;ans; return 0;// for(int i=0;i&lt;t;i++)//找出现次数最多是几次// maxTimes=max(arr[i],arr[i+1]);// for(int i=0;i&lt;=t;i++){// if(arr[i]==maxTimes){// cout&lt;&lt;i+1;// return 0;// }// }} 数组中连续m个数和的最小值爱与愁的心痛 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int arr[3010];int main(){ int n,m,Min=0x3fffffff; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) cin&gt;&gt;arr[i]; for(int i=0;i&lt;=n-m;i++){/*必须是&lt;=,因为下方for循环中j&lt;i+m,不含=*/ int sum=0; for(int j=i;j&lt;i+m;j++)//直接从i往后加m个数即可 sum+=arr[j]; Min=min(Min,sum); } cout&lt;&lt;Min; return 0;} 工艺品制作https://www.luogu.com.cn/problem/P5729 注意：用Bool型数组进行标记 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;bool square[20][20][20];int main(){ int w,x,h,q,x1,y1,z1,x2,y2,z2; cin&gt;&gt;w&gt;&gt;x&gt;&gt;h&gt;&gt;q; int count=0; int sum=w*x*h; for(int i=0;i&lt;w;i++){ for(int j=0;j&lt;x;j++){ for(int k=0;k&lt;h;k++) square[i][j][k]=false; } } for(int i=0;i&lt;q;i++){ cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;z1&gt;&gt;x2&gt;&gt;y2&gt;&gt;z2; for(int j=x1;j&lt;=x2;j++){ for(int k=y1;k&lt;=y2;k++){ for(int t=z1;t&lt;=z2;t++){ if(!square[j][k][t]){ count++; square[j][k][t]=true; } } } } } cout&lt;&lt;sum-count; return 0;} 数字直角三角形https://www.luogu.com.cn/problem/P5721?contestId=62093 注意：每行输出5，4，3，2，1个数字的条件 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int main(){ int n,i=1,count=0; scanf(&quot;%d&quot;,&amp;n); int sum=n*(n+1)/2; while(i&lt;=sum){ printf(&quot;%02d&quot;,i); count++; if(count==n){ printf(&quot;\\n&quot;); n--; count=0; } i++; } return 0;} 数字三角形https://www.luogu.com.cn/problem/P5725?contestId=62093 注意：每行输出1，2，3，4……个数字的实现，且每轮输出靠右 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int arr[10][10];int main(){ int n; cin&gt;&gt;n; for(int i=1;i&lt;=n*n;i++){ printf(&quot;%02d&quot;,i); if(i%n==0) cout&lt;&lt;endl; } cout&lt;&lt;endl;/*下列方法不能实现靠右输出*/// int t=1,count=1,tmp=0;//t是每次要输出的数，count是每行可以输出的数字个数，tmp记录已经输出了几个// while(t&lt;=n*(n+1)/2){// printf(&quot;%02d&quot;,t);// tmp++;// if(tmp==count){// printf(&quot;\\n&quot;);// count++;// tmp=0;// }// t++;// } int count=1; for(int i=1;i&lt;=n;i++){ for(int j=n-i;j&gt;0;j--){ printf(&quot; &quot;); } for(int k=0;k&lt;i;k++){ printf(&quot;%02d&quot;,count); count++; } printf(&quot;\\n&quot;); } return 0;} 存钱https://www.luogu.com.cn/problem/P4956?contestId=62093 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;int main() { int n; scanf(&quot;%d&quot;, &amp;n); int x, k; for (k = 1;; k++) { for (x = 1; x &lt;=100; x++) {//不确定k的停止条件可以不写！！！ int day = 0; //星期几 int sum = 0; int count=0;//所用天数 /*模拟筹钱过程，while的每次循环就是筹一天钱*/ while (sum &lt;= n &amp;&amp; count&lt;=52*7) { sum += x + day * k; if (sum == n) { printf(&quot;%d\\n%d&quot;, x, k); return 0; } day++; day %= 7; count++; } } }} 数组计数问题https://www.luogu.com.cn/problem/P1980?contestId=62093 1234567891011121314151617181920#include &lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int arr[10];int main() { fill(arr,arr+10,0); int n, x; cin &gt;&gt; n &gt;&gt; x; for(int i=1;i&lt;=n;i++){ int j=i; //注意这里一定要重新定义一个数，不能直接用i计算，否则会改变循环 while(j!=0){ arr[j%10-1]++; j/=10; } } cout&lt;&lt;arr[x-1]; return 0;} 按下标排序ABC 1234567891011121314#include&lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int num[3]; for(int i=0;i&lt;3;i++) cin&gt;&gt;num[i]; string s; sort(num,num+3); cin&gt;&gt;s; cout&lt;&lt;num[s[0]-'A']&lt;&lt;&quot; &quot;&lt;&lt;num[s[1]-'A']&lt;&lt;&quot; &quot;&lt;&lt;num[s[2]-'A']; return 0;} 回文质数回文质数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;sstream&gt;#include&lt;algorithm&gt;using namespace std;/*判断数n是不是质数*/bool isPrime(int n){ for(int i=2;i*i&lt;=n;i++){ if(n%i==0) return false; } return true;}stringstream ss;//写在函数外面，不用每次调用函数都执行这步，减少时间/*判断数n是不是回文*///方法一bool check1(int n){ ss&lt;&lt;n; string str; ss&gt;&gt;str; /*下面两步才能真正清空stringstream,第一步修改标志位为空，第二步清空*/ ss.clear(); ss.str(&quot;&quot;); string str2=str; reverse(str2.begin(),str2.end()); return str2==str;}//方法二int arr[10];bool check(int n){ int count=0; while(n){ arr[count]=n%10; n/=10; count++; } int i=0,j=count-1; while(i&lt;j){ if(arr[i]!=arr[j]) return false; i++; j--; } return true;}/*数字位数是偶数的，除了11，其他都是11的倍数（因此不是质数），不符合条件*//*因此符合条件的数一定是：数字位数是奇数的数（11除外）*/int main(){ int a,b; cin&gt;&gt;a&gt;&gt;b; if(b&gt;9999999)//大于9999999的数（位数是8位，偶数位）不可能是质数 b=9999999; for(int i=a;i&lt;=b;i+=2){ if(i%2==0) i++; if(check(i) &amp;&amp; isPrime(i)) //先check才能不超时！！！！ printf(&quot;%d\\n&quot;,i); } return 0;} 对角线交点对角线 123456789#include&lt;iostream&gt;using namespace std;int main(){ unsigned long long n; //数据范围 cin&gt;&gt;n; cout&lt;&lt;n*(n-1)/2*(n-2)/3*(n-3)/4; return 0;} ISBN转换ISBN 注意字符和int型进行加减运算的结果 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;int main() { string s; cin &gt;&gt; s; int sum = 0, tmp = 1; for (int i = 0; i &lt; 12; i++) { if (s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9') { sum += tmp * (s[i] - '0'); tmp++; } } sum %= 11; if (sum == 10) { //余数是10 if (s[12] == 'X') cout &lt;&lt; &quot;Right&quot;; else { for (int i = 0; i &lt; 12; i++) cout &lt;&lt; s[i]; cout &lt;&lt; 'X'; } } else { //余数不是10 if (sum == (s[12] - '0')) cout &lt;&lt; &quot;Right&quot;; else { for (int i = 0; i &lt; 12; i++) cout &lt;&lt; s[i]; cout &lt;&lt; sum; } } return 0;}","link":"/2022/04/17/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"blog更新过程","text":"博客更新过程 在D:\\Blog\\source\\_posts文件夹下写博客 怎么在本地写博客内容 在md文件第一行输入三个-然后回车，可以输入标题等信息，注意有空格title:空格然后输入内容 还可以输入信息cateogry: xx，输入分类信息 在D:\\Blog文件夹上右键，选择git bash here 输入hexo g &amp;&amp; hexo d，经过处理后如果显示Deploy done: git则表示已完成","link":"/2022/04/17/blog%E8%BF%87%E7%A8%8B/"}],"tags":[],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"}]}