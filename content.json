{"pages":[],"posts":[{"title":"算法与数据结构","text":"C++面向对象封装真正的面向对象的编程需要对象支持三种特性：封装、继承和多态性。 True object-orient programming requires objects to support three qualities: encapsulation, inheritance, and polymorphism. 继承多态常用算法动态规划最长回文子序列 123456789101112131415161718192021222324252627282930class Solution {public: static const int N=1010; int dp[N][N]; int longestPalindromeSubseq(string s) { int n=s.size(); for(int i=n-1;i&gt;=0;i--){ for(int j=i;j&lt;n;j++){ if(i==j){ dp[i][j]=1; continue; } if(i+1==j){ if(s[i]==s[j]) dp[i][j]=2; else dp[i][j]=1; continue; } int tmp=max(dp[i][j-1],dp[i+1][j]); if(s[i]==s[j]) dp[i][j]=max(tmp,2+dp[i+1][j-1]); else dp[i][j]=tmp; } } return dp[0][n-1]; }}; 最长递增子序列 123456789101112int lengthOfLIS(vector&lt;int&gt;&amp; nums) { int n=nums.size(); int ans=1; vector&lt;int&gt;dp(n,1); for(int i=1;i&lt;n;i++){ for(int j=0;j&lt;i;j++) if(nums[i]&gt;nums[j]) dp[i]=max(dp[i],dp[j]+1); ans=max(ans,dp[i]); } return ans; } 前缀和与差分前缀和与差分可快速计算出任意两个区间之间的和 //真题：2017_3 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int c,x,ans=0;int main(){ cin&gt;&gt;c&gt;&gt;x; vector&lt;int&gt;arr(c,0); vector&lt;int&gt;preSum(c,0); for(int i=0;i&lt;c;i++) cin&gt;&gt;arr[i]; preSum[0]=arr[0]; for(int i=1;i&lt;c;i++) preSum[i]=preSum[i-1]+arr[i]; for(int i=0;i&lt;c;i++){ for(int j=i;j&lt;c;j++){ int t; if(i==0) t=preSum[j]; else t=preSum[j]-preSum[i-1];//t表示arr[i]到arr[j]的所有数字的和(包括i和j) if(t&gt;=x) ans++; } } cout&lt;&lt;ans; return 0;} 递归加回溯N皇后 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;algorithm&gt; #include&lt;vector&gt;using namespace std;vector&lt;vector&lt;int&gt; &gt;ans;vector&lt;int&gt;path;//path[i]表示第i+1行的皇后所在列，整个path表示一种方案 bool col[100],Left[100],Right[100]; //初始值为false，表示没有放皇后 int n,res=0;;bool check(int c,int l,int r){//判断皇后是否能放在k行i列 return !col[c] &amp;&amp; !Left[l] &amp;&amp; !Right[r];}void dfs(int k){//皇后放在第k行的情况 if(k==n){ ans.push_back(path); res++; return; } //选路 for(int i=0;i&lt;n;i++){//(k,i)表示皇后放在第k行第i列 int c=i;//行 int l=k+i;//列 int r=n-(i-k+1);//右对角线 if(!check(c,l,r)) continue; col[c]=true; Left[l]=true; Right[r]=true; path.push_back(i+1); //递归 dfs(k+1); //回溯 col[c]=false; Left[l]=false; Right[r]=false; path.pop_back(); } }int main(){ cin&gt;&gt;n; dfs(0); sort(ans.begin(),ans.end()); for(int i=0;i&lt;3;i++){ for(int j=0;j&lt;n;j++){ cout&lt;&lt;ans[i][j]&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; } cout&lt;&lt;res; return 0;} 求第K小的数案例：求第 k 小的数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;ctime&gt;using namespace std;int partition(vector&lt;int&gt; &amp;arr, int low, int high) { int p=rand()%(high-low+1)+low; int pivot = arr[p]; /*下面操作使arr[low]换回来，防止出错*/ int tmp=arr[p]; arr[p]=arr[low]; arr[low]=tmp; while (low &lt; high) { /*从右边找小于基准的*/ while (low &lt; high &amp;&amp; arr[high] &gt;= pivot) high--; arr[low] = arr[high]; /*从左边找大于基准的*/ while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) low++; arr[high] = arr[low]; } arr[low] = pivot; return low;}int ans; //最终的元素小标void func(vector&lt;int&gt; &amp;arr, int left, int right, int k) { /*确定一个元素的最终位置：选取基准元素，将小的放左边，大的放右边*/ int t = partition(arr, left, right); /*看基准下标和k的关系*/ if (t == k){ ans = t; return; } else if (t &gt; k) func(arr, left, t - 1, k); else func(arr, t + 1, right, k);}int main() { srand((unsigned)time(NULL)); int n, k, x; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; arr(n); for (int i = 0; i&lt; n; i++){ scanf(&quot;%d&quot;,&amp;x); //写cin就超时 arr[i]=x; } func(arr,0,n-1,k); cout&lt;&lt;arr[ans]; return 0;} 排序快速排序（取随机数优化了）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include &lt;ctime&gt; //取随机种子需要这个头文件using namespace std;int arr[100001];int partition(int arr[], int low, int high) { int p=rand()%(high-low+1)+low; //从下标low到high中取随机数 int pivot = arr[p]; /*下面操作使arr[low]换回来，防止出错*/ int tmp=arr[p]; arr[p]=arr[low]; arr[low]=tmp; while (low &lt; high) { /*从右边找小于基准的*/ while (low &lt; high &amp;&amp; arr[high] &gt;= pivot) high--; arr[low] = arr[high]; /*从左边找大于基准的*/ while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) low++; arr[high] = arr[low]; } arr[low] = pivot; return low;}void quickSort(int arr[], int low, int high) { if (low &gt;= high) return; int pivotpos = partition(arr, low, high); quickSort(arr, low, pivotpos - 1); quickSort(arr, pivotpos + 1, high);}int main() { srand((unsigned)time(NULL)); //取随机种子，取随机数必须要写的 int n; scanf(&quot;%d&quot;,&amp;n); for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;,&amp;arr[i]); quickSort(arr, 0, n - 1); for (int i = 0; i &lt; n; i++) printf(&quot;%d &quot;,arr[i]); return 0;} 注：随机打乱数据，防止因为数据基本有序或大量重复元素导致时间复杂度为O(n2) 直接插入排序堆排序STL用法lower_bound和upper_boundlower_bound(first,last,val)是返回第一个值大于等于val的元素的位置（指针或迭代器），可以减去开头指针和开头迭代器来获得元素下标；upper_bound(first,last,val)是返回第一个值大于val的元素的位置（指针或迭代器），可以减去开头指针和开头迭代器来获得元素下标。如果没有就返回考研插入val的位置 注意：数组或容器里元素必须递增有序，因为底层用的是二分查找！ 例题 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt; using namespace std;int m,n;int main(){ cin&gt;&gt;m&gt;&gt;n; long long ans=0; vector&lt;int&gt;line(m);//分数线 vector&lt;int&gt;score(n);//同学估的分 for(int i=0;i&lt;m;i++) cin&gt;&gt;line[i]; for(int i=0;i&lt;n;i++) cin&gt;&gt;score[i]; sort(line.begin(),line.end()); for(int i=0;i&lt;n;i++){ //pos表示第一个大于等于score[i]的元素下标 int pos=lower_bound(line.begin(),line.end(),score[i])-line.begin(); if(pos==0) ans+=abs(score[i]-line[0]); else if(pos==m) ans+=abs(score[i]-line[m-1]); else ans+=min(abs(score[i]-line[pos]),abs(score[i]-line[pos-1])); } cout&lt;&lt;ans; return 0; } maphttps://www.luogu.com.cn/problem/P1125#submit 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;//是否是质数bool isPrime(int n){ if(n&lt;2) return false; for(int i=2;i*i&lt;=n;i++){ if(n%i==0) return false; } return true;} int main(){ int maxn=0,minn=110; string s; cin&gt;&gt;s; map&lt;char,int&gt;mp;//map是自动按照key值排序的 for(int i=0;i&lt;s.size();i++) mp[s[i]]++; //中括号 for(map&lt;char,int&gt;::iterator it=mp.begin();it!=mp.end();it++){ maxn=max(maxn,it-&gt;second);//怎么输出key指向的value minn=min(minn,(*it).second); } int t=maxn-minn; if(isPrime(t)) cout&lt;&lt;&quot;Lucky Word&quot;&lt;&lt;endl&lt;&lt;t; else cout&lt;&lt;&quot;No Answer&quot;&lt;&lt;endl&lt;&lt;0; return 0; } sort自定义排序案例：奖学金 C++98标准写法 cmp函数中必须加const,否则会报错！！！ 注意：自定义比较函数的参数最好加引用，否则会因为需要创建大量副本而导致程序超时 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;struct stu { int sum, chinese, id; stu(int s, int c, int i) { sum = s; chinese = c; id = i; }};/*定义什么情况下A排在B前面（只考虑小于不考虑相等和大于）*/bool cmp(const stu &amp;A,const stu &amp;B) {//必须加const，否则会报错 if (A.sum &gt; B.sum) return true; if (A.sum == B.sum &amp;&amp; A.chinese &gt; B.chinese) return true; if (A.sum == B.sum &amp;&amp; A.chinese == B.chinese &amp;&amp; A.id &lt; B.id) return true; return false;}int main() { int n; cin &gt;&gt; n; int a, b, c; vector&lt;stu&gt; arr; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; arr.push_back(stu(a + b + c, a, i + 1)); } sort(arr.begin(), arr.end(), cmp); for (int i = 0; i &lt; 5; i++) { cout &lt;&lt; arr[i].id &lt;&lt; &quot; &quot; &lt;&lt; arr[i].sum&lt;&lt;endl; }} Lambda表达式写法 123456789sort(arr.begin(), arr.end(), [](stu &amp;A, stu &amp;B) { if (A.sum &gt; B.sum) return true; if (A.sum == B.sum &amp;&amp; A.chinese &gt; B.chinese) return true; if (A.sum == B.sum &amp;&amp; A.chinese == B.chinese &amp;&amp; A.id &lt; B.id) return true; return false;}); vector构建二维动态数组案例：烤鸡调料 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int sup[10]; //每种配料的数量int n;vector&lt;vector&lt;int&gt;&gt;ans; //二维vector/*选择第第k种配料的数量*/void f(int k){ #include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt;arr;//存最后的二维数组vector&lt;int&gt;num(10);//每种调料放多少int n,ansCount=0;/*在num[k]填数*/void func(int k){ /*终止条件*/ if(k==10){ int sum=0; for(int i=0;i&lt;10;i++) sum+=num[i]; if(sum==n){ arr.push_back(num); ansCount++; } return; } /*递归主体*/ num[k]=1; /*当前，当前节点值可能是1*/ func(k+1); /*后序*/ num[k]=2; /*也可能是2*/ func(k+1); num[k]=3; /*也可能是3*/ func(k+1);}int main(){ cin&gt;&gt;n; func(0); cout&lt;&lt;ansCount&lt;&lt;endl; for(int i=0;i&lt;ansCount;i++){ for(int j=0;j&lt;10;j++) cout&lt;&lt;arr[i][j]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; } return 0;} /*10种配料全部选完，看看是否符合要求*/ if(k==10){ int sum=0; for(int i=0;i&lt;10;i++){ sum+=sup[i]; } /*符合要求，把结果存起来*/ if(sum==n){ //把数填进二维动态数组中 vector&lt;int&gt;t; for(int i=0;i&lt;10;i++) t.push_back(sup[i]); ans.push_back(t); } return; } sup[k]=1; f(k+1); sup[k]=2; f(k+1); sup[k]=3; f(k+1); // for(int i=1;i&lt;=3;i++){// sup[k]=i;// f(k+1);// }}int main(){ cin&gt;&gt;n; f(0); cout&lt;&lt;ans.size()&lt;&lt;endl; for(int i=0;i&lt;ans.size();i++){ for(int j=0;j&lt;ans[i].size();j++){ cout&lt;&lt;ans[i][j]&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; } return 0;} 数学问题及其他高精度加法走楼梯 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;int n,len=1,arr[5010][1100];void cal(int k){/*计算第k台阶的方法数*/ for(int i=0;i&lt;len;i++) arr[k][i]=arr[k-1][i]+arr[k-2][i]; for(int i=0;i&lt;len;i++){ arr[k][i+1]+=arr[k][i]/10;//处理进位 arr[k][i]%=10;//存余，处理当前位 if(arr[k][len]!=0)//处理长度变化 len++; }}int main(){ cin&gt;&gt;n; arr[0][0]=1;//无意义，辅助链式计算 arr[1][0]=1; for(int i=2;i&lt;=n;i++) cal(i); for(int i=len-1;i&gt;=0;i--)//逆序输出 cout&lt;&lt;arr[n][i]; return 0;} 高精度加法和高精度乘法阶乘之和 1234567891011//不用高精度运算时int main(){ int n,sum=0,tmp=1; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ tmp*=i; sum+=tmp; } cout&lt;&lt;sum; return 0;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int sum[2000];//存储最终答案，初始为0int len_sum=0; int tmp[2000];//存储中间乘法结果，初始为1int len_tmp=1;int t[2000];//装高精度数i int len_t=0;//将数字倒序存储在数组中，返回数组长度int transfer(int n,int t[]){ //不用加引用，因为t[]本身就表示指向数组首地址的指针 if(n==0){ t[0]=0; return 1; } int i=0,len=0; while(n){ t[i++]=n%10; n/=10; len++; } return len;}//实现tmp=tmp*i:两个数组装高精度数，分别表示tmp和i,最终返回tmp数组的长度 int multiple(int a[],int lena,int b[],int lenb){ int lenc=lena+lenb; vector&lt;int&gt;c(lenc,0); for(int i=0;i&lt;lena;i++){ for(int j=0;j&lt;lenb;j++){ c[i+j]+=a[i]*b[j]; } } //进位存余 for(int i=0;i&lt;lenc;i++){ c[i+1]+=c[i]/10; c[i]%=10; } while(lenc&gt;1 &amp;&amp; c[lenc-1]==0) lenc--; //把结果存回a[] for(int i=0;i&lt;lenc;i++) a[i]=c[i]; return lenc; }void show(int a[],int len){ for(int i=0;i&lt;len;i++) cout&lt;&lt;a[len-1-i];} //实现sum=sum+tmp:两个数组装高精度数，分别表示sum和tmp，最终返回sum数组的长度 int add(int a[],int len1,int b[],int len2){ int n=max(len1,len2)+1; vector&lt;int&gt;c(n,0); //先加 for(int i=0;i&lt;n;i++) c[i]=a[i]+b[i]; //进位存余 for(int i=0;i&lt;n;i++){ c[i+1]+=c[i]/10; c[i]%=10; } while(n&gt;1 &amp;&amp; c[n-1]==0) n--; //把结果存回a[] for(int i=0;i&lt;n;i++) a[i]=c[i]; return n; }int main(){ int n; cin&gt;&gt;n; fill(sum,sum+2000,0); fill(tmp,tmp+2000,0); tmp[0]=1; for(int i=1;i&lt;=n;i++){ len_t=transfer(i,t); len_tmp=multiple(tmp,len_tmp,t,len_t);//tmp*=i len_sum=add(sum,len_sum,tmp,len_tmp);//sum+=tmp } for(int i=0;i&lt;len_sum;i++) cout&lt;&lt;sum[len_sum-1-i]; return 0;} 求最大公因数123456#include &lt;iostream&gt;using namespace std;int gcd(int a, int b) { return !b ? a : gcd(b, a % b);} 闰年判断123456//闰年：//能被4整除，不能被100整除。//能被4整除，也能被100整除。（能被400整除）bool isLeapYear(int n){ return n%400==0 || n%4==0 &amp;&amp; n%100!=0;} 排列数（递归+回溯）排列数有顺序，递归树可以有n个分支 1~9分成3个数，成比例 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;using namespace std;int num[9];bool flag[9];int a,b,c,count=0;/*选中或者不选num[k]*/void func(int k){ /*终止条件*/ if(k==9){ int p1=num[0]*100+num[1]*10+num[2]; int p2=num[3]*100+num[4]*10+num[5]; int p3=num[6]*100+num[7]*10+num[8]; int t=p1*b*c; if(t==p2*a*c &amp;&amp; t==p3*a*b){ cout&lt;&lt;p1&lt;&lt;&quot; &quot;&lt;&lt;p2&lt;&lt;&quot; &quot;&lt;&lt;p3&lt;&lt;endl; count++; } return; } /*递归主体*/ //num[k]=1;func(k+1); //num[k]=2;func(k+1);回溯 //…… //num[k]=9;func(k+1); for(int i=1;i&lt;10;i++){ if(!flag[i-1]){ num[k]=i; flag[i-1]=true; func(k+1); flag[i-1]=false; } }}int main(){ fill(flag,flag+9,false); cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; func(0); if(count==0) cout&lt;&lt;&quot;No!!!&quot;; return 0;} 组合数（递归+回溯）组合数没有顺序，递归树中每个结点只有两个分支：选或者不选 选数求和，和是否是素数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;int arr[20],num[20];//arr装输入的数，num装选中的数int ans=0,count=0,n,k;//ans表示最终答案,count表示选中的数的个数/*是否是素数*/bool isPrime(int n){ if(n&lt;=1) return false; for(int i=2;i&lt;n;i++){ if(n%i==0) return false; } return true;}/*递归选数：选或不选arr[t]*/void func(int t){/*终止条件*/ if(count==k){/*如果已经选中了k个数*/ int sum=0; for(int i=0;i&lt;k;i++) sum+=num[i]; if(isPrime(sum)) ans++; return; } if(t==n)/*如果t越界*/ return;/*递归主体*/ /*选arr[t]*/ num[count++]=arr[t]; func(t+1); count--; /*不选arr[t]*/ func(t+1);}int main(){ cin&gt;&gt;n&gt;&gt;k; for(int i=0;i&lt;n;i++) cin&gt;&gt;arr[i]; func(0); cout&lt;&lt;ans; return 0;} 组合的输出 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int n,r,count=0;vector&lt;int&gt;arr;//存放选中的数/*选不选k*/void func(int k){/*终止条件*/ /*已经选了r个数*/ if(count==r){ for(int i=0;i&lt;r;i++) printf(&quot;%3d&quot;,arr[i]); printf(&quot;\\n&quot;); return; } /*k越界*/ if(k==n+1) return;/*递归主体*/ /*选中k*/ arr.push_back(k); count++; func(k+1); arr.pop_back(); count--; /*不选k*/ func(k+1);}int main(){ cin&gt;&gt;n&gt;&gt;r; func(1); return 0;} 全排列全排列 注意： 序列必须已经从小到大排序好才能使用next_permutation next_permutation会自动去重(例如1,1,2) 1234567891011121314151617#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int arr[9];int main(){ int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) arr[i]=i+1; do{ for(int i=0;i&lt;n;i++) printf(&quot;%5d&quot;,arr[i]); printf(&quot;\\n&quot;); }while(next_permutation(arr,arr+n));} 火星人 123456789101112131415161718#include&lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int n,m; cin&gt;&gt;n&gt;&gt;m; vector&lt;int&gt;input(n); for(int i=0;i&lt;n;i++) cin&gt;&gt;input[i]; while(m--) next_permutation(input.begin(),input.end());//注意不能写input+n for(int i=0;i&lt;n;i++) cout&lt;&lt;input[i]&lt;&lt;&quot; &quot;; return 0;} 有价值的题目map,sort自定义排序南理工2015年真题第七题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;map&lt;int,int&gt;mp;//key表示数字，value表示出现次数 vector&lt;int&gt;arr; struct Num{ int data,cnt; Num(int a,int b){ data=a; cnt=b; } Num(){}};vector&lt;Num&gt;vec;int findPos(int k){ for(int i=0;i&lt;arr.size();i++){ if(arr[i]==k) return i; }}bool cmp(const Num &amp;A,const Num &amp;B){ int pos_a=findPos(A.data); int pos_b=findPos(B.data); return A.cnt&gt;B.cnt || A.cnt==B.cnt &amp;&amp; pos_a&lt;pos_b;}int main(){ while(true){ int x; cin&gt;&gt;x; if(x==-1) break; if(mp.find(x)==mp.end()) arr.push_back(x); mp[x]++; } for(int i=0;i&lt;arr.size();i++) cout&lt;&lt;arr[i]&lt;&lt;&quot;:&quot;&lt;&lt;mp[arr[i]]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; for(map&lt;int,int&gt;::iterator it=mp.begin();it!=mp.end();it++) vec.push_back(Num(it-&gt;first,it-&gt;second)); int n=vec.size(); sort(vec.begin(),vec.end(),cmp); for(int i=0;i&lt;n;i++) cout&lt;&lt;vec[i].data&lt;&lt;&quot;:&quot;&lt;&lt;vec[i].cnt&lt;&lt;&quot; &quot;; return 0; } sscanf和sprintf，使string类型输出int型口算练习题 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;char str[100],tmp[10];/*str存储最终的字符串*/int main(){ char ch;/*接收a,b,c，用于表示运算符*/ int n,p1,p2;/*p1,p2表示两个运算数*/ cin&gt;&gt;n; for(int i=0;i&lt;n;i++){ cin&gt;&gt;tmp;/*输入一串字符串*/ if(tmp[0]&gt;='a' &amp;&amp; tmp[0]&lt;='z'){ ch=tmp[0];/*如果是运算符,用ch接收*/ cin&gt;&gt;p1&gt;&gt;p2;/*并且继续输入数字*/ } else{ sscanf(tmp,&quot;%d&quot;,&amp;p1);/*如果是数字，就转换tmp[0]为int存到第一个数字p1中*/ cin&gt;&gt;p2;/*输入第二个数*/ } //memset(str,0,sizeof(str));/*清空str*/ if(ch=='a')/*如果输入了两个数，ch就是上个回合的ch不变，就保证了运算符一致*/ sprintf(str,&quot;%d+%d=%d&quot;,p1,p2,p1+p2); else if(ch=='b') sprintf(str,&quot;%d-%d=%d&quot;,p1,p2,p1-p2); else if(ch=='c') sprintf(str,&quot;%d*%d=%d&quot;,p1,p2,p1*p2); cout&lt;&lt;str&lt;&lt;endl&lt;&lt;strlen(str)&lt;&lt;endl; } return 0;} ASCII码中26个小写字母的循环输出后移n位后输出 123456789101112#include&lt;iostream&gt;using namespace std;int main(){ int n; string s; cin&gt;&gt;n&gt;&gt;s; for(int i=0;i&lt;s.size();i++){ s[i]=(s[i]+n-'a')%26+'a';//实现循环 cout&lt;&lt;s[i]; } return 0;} 贪心算法区间问题 注意：每次选区间右端点最小或者左端点最大的区间 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int n;struct Time { int a, b; Time(int x,int y){ a=x; b=y; } Time(){}};bool cmp(Time &amp;A, Time &amp;B) {//先选右端点最小的，按右端点从小到大排序 return A.b &lt; B.b;}int main() { cin &gt;&gt; n; vector&lt;Time&gt; arr(n); for (int i = 0; i &lt; n; i++) { int x,y; cin&gt;&gt;x&gt;&gt;y; Time t(x,y);//t是变量名，可以随便取 arr[i]=t; } sort(arr.begin(), arr.end(), cmp); int ans = 0; int rightEdge=0; //上一个被选中的区间的右端点 for (int i = 0; i &lt; n; i++) { if(arr[i].a&gt;=rightEdge){ rightEdge=arr[i].b; ans++; } } cout &lt;&lt; ans; return 0;} 求三个数的和出现次数最多是几次1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int s1,s2,s3,ans,maxTimes=0;; cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3; int t=s1+s2+s3; int arr[t+1]; fill(arr,arr+t+1,0); for(int i=1;i&lt;=s1;i++){ for(int j=1;j&lt;=s2;j++){ for(int k=1;k&lt;=s3;k++){ arr[i+j+k]++; if(arr[i+j+k]&gt;maxTimes){//&gt;而不是&gt;=，可以确保如果有好多个和出现频率一样最高，可以输出第一个频率最高的 maxTimes=arr[i+j+k];//在题目中就可以实现 ans=i+j+k; } } } } cout&lt;&lt;ans; return 0;// for(int i=0;i&lt;t;i++)//找出现次数最多是几次// maxTimes=max(arr[i],arr[i+1]);// for(int i=0;i&lt;=t;i++){// if(arr[i]==maxTimes){// cout&lt;&lt;i+1;// return 0;// }// }} 数组中连续m个数和的最小值爱与愁的心痛 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int arr[3010];int main(){ int n,m,Min=0x3fffffff; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) cin&gt;&gt;arr[i]; for(int i=0;i&lt;=n-m;i++){/*必须是&lt;=,因为下方for循环中j&lt;i+m,不含=*/ int sum=0; for(int j=i;j&lt;i+m;j++)//直接从i往后加m个数即可 sum+=arr[j]; Min=min(Min,sum); } cout&lt;&lt;Min; return 0;} 工艺品制作https://www.luogu.com.cn/problem/P5729 注意：用Bool型数组进行标记 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;bool square[20][20][20];int main(){ int w,x,h,q,x1,y1,z1,x2,y2,z2; cin&gt;&gt;w&gt;&gt;x&gt;&gt;h&gt;&gt;q; int count=0; int sum=w*x*h; for(int i=0;i&lt;w;i++){ for(int j=0;j&lt;x;j++){ for(int k=0;k&lt;h;k++) square[i][j][k]=false; } } for(int i=0;i&lt;q;i++){ cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;z1&gt;&gt;x2&gt;&gt;y2&gt;&gt;z2; for(int j=x1;j&lt;=x2;j++){ for(int k=y1;k&lt;=y2;k++){ for(int t=z1;t&lt;=z2;t++){ if(!square[j][k][t]){ count++; square[j][k][t]=true; } } } } } cout&lt;&lt;sum-count; return 0;} 数字直角三角形https://www.luogu.com.cn/problem/P5721?contestId=62093 注意：每行输出5，4，3，2，1个数字的条件 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int main(){ int n,i=1,count=0; scanf(&quot;%d&quot;,&amp;n); int sum=n*(n+1)/2; while(i&lt;=sum){ printf(&quot;%02d&quot;,i); count++; if(count==n){ printf(&quot;\\n&quot;); n--; count=0; } i++; } return 0;} 数字三角形https://www.luogu.com.cn/problem/P5725?contestId=62093 注意：每行输出1，2，3，4……个数字的实现，且每轮输出靠右 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int arr[10][10];int main(){ int n; cin&gt;&gt;n; for(int i=1;i&lt;=n*n;i++){ printf(&quot;%02d&quot;,i); if(i%n==0) cout&lt;&lt;endl; } cout&lt;&lt;endl;/*下列方法不能实现靠右输出*/// int t=1,count=1,tmp=0;//t是每次要输出的数，count是每行可以输出的数字个数，tmp记录已经输出了几个// while(t&lt;=n*(n+1)/2){// printf(&quot;%02d&quot;,t);// tmp++;// if(tmp==count){// printf(&quot;\\n&quot;);// count++;// tmp=0;// }// t++;// } int count=1; for(int i=1;i&lt;=n;i++){ for(int j=n-i;j&gt;0;j--){ printf(&quot; &quot;); } for(int k=0;k&lt;i;k++){ printf(&quot;%02d&quot;,count); count++; } printf(&quot;\\n&quot;); } return 0;} 存钱https://www.luogu.com.cn/problem/P4956?contestId=62093 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;int main() { int n; scanf(&quot;%d&quot;, &amp;n); int x, k; for (k = 1;; k++) { for (x = 1; x &lt;=100; x++) {//不确定k的停止条件可以不写！！！ int day = 0; //星期几 int sum = 0; int count=0;//所用天数 /*模拟筹钱过程，while的每次循环就是筹一天钱*/ while (sum &lt;= n &amp;&amp; count&lt;=52*7) { sum += x + day * k; if (sum == n) { printf(&quot;%d\\n%d&quot;, x, k); return 0; } day++; day %= 7; count++; } } }} 数组计数问题https://www.luogu.com.cn/problem/P1980?contestId=62093 1234567891011121314151617181920#include &lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int arr[10];int main() { fill(arr,arr+10,0); int n, x; cin &gt;&gt; n &gt;&gt; x; for(int i=1;i&lt;=n;i++){ int j=i; //注意这里一定要重新定义一个数，不能直接用i计算，否则会改变循环 while(j!=0){ arr[j%10-1]++; j/=10; } } cout&lt;&lt;arr[x-1]; return 0;} 按下标排序ABC 1234567891011121314#include&lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int num[3]; for(int i=0;i&lt;3;i++) cin&gt;&gt;num[i]; string s; sort(num,num+3); cin&gt;&gt;s; cout&lt;&lt;num[s[0]-'A']&lt;&lt;&quot; &quot;&lt;&lt;num[s[1]-'A']&lt;&lt;&quot; &quot;&lt;&lt;num[s[2]-'A']; return 0;} 回文质数回文质数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;sstream&gt;#include&lt;algorithm&gt;using namespace std;/*判断数n是不是质数*/bool isPrime(int n){ for(int i=2;i*i&lt;=n;i++){ if(n%i==0) return false; } return true;}stringstream ss;//写在函数外面，不用每次调用函数都执行这步，减少时间/*判断数n是不是回文*///方法一bool check1(int n){ ss&lt;&lt;n; string str; ss&gt;&gt;str; /*下面两步才能真正清空stringstream,第一步修改标志位为空，第二步清空*/ ss.clear(); ss.str(&quot;&quot;); string str2=str; reverse(str2.begin(),str2.end()); return str2==str;}//方法二int arr[10];bool check(int n){ int count=0; while(n){ arr[count]=n%10; n/=10; count++; } int i=0,j=count-1; while(i&lt;j){ if(arr[i]!=arr[j]) return false; i++; j--; } return true;}/*数字位数是偶数的，除了11，其他都是11的倍数（因此不是质数），不符合条件*//*因此符合条件的数一定是：数字位数是奇数的数（11除外）*/int main(){ int a,b; cin&gt;&gt;a&gt;&gt;b; if(b&gt;9999999)//大于9999999的数（位数是8位，偶数位）不可能是质数 b=9999999; for(int i=a;i&lt;=b;i+=2){ if(i%2==0) i++; if(check(i) &amp;&amp; isPrime(i)) //先check才能不超时！！！！ printf(&quot;%d\\n&quot;,i); } return 0;} 对角线交点对角线 123456789#include&lt;iostream&gt;using namespace std;int main(){ unsigned long long n; //数据范围 cin&gt;&gt;n; cout&lt;&lt;n*(n-1)/2*(n-2)/3*(n-3)/4; return 0;} ISBN转换ISBN 注意字符和int型进行加减运算的结果 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;int main() { string s; cin &gt;&gt; s; int sum = 0, tmp = 1; for (int i = 0; i &lt; 12; i++) { if (s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9') { sum += tmp * (s[i] - '0'); tmp++; } } sum %= 11; if (sum == 10) { //余数是10 if (s[12] == 'X') cout &lt;&lt; &quot;Right&quot;; else { for (int i = 0; i &lt; 12; i++) cout &lt;&lt; s[i]; cout &lt;&lt; 'X'; } } else { //余数不是10 if (sum == (s[12] - '0')) cout &lt;&lt; &quot;Right&quot;; else { for (int i = 0; i &lt; 12; i++) cout &lt;&lt; s[i]; cout &lt;&lt; sum; } } return 0;}","link":"/2022/04/17/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"blog更新过程","text":"博客更新过程 在D:\\Blog\\source\\_posts文件夹下写博客 怎么在本地写博客内容 在md文件第一行输入三个-然后回车，可以输入标题等信息，注意有空格title:空格然后输入内容 还可以输入信息cateogry: xx，输入分类信息 在D:\\Blog文件夹上右键，选择git bash here 输入hexo g &amp;&amp; hexo d，经过处理后如果显示Deploy done: git则表示已完成 如果失败可以尝试hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 小技巧 在文章中间输入&lt;!--more--&gt;可以生成预览 常用的yml配置 title: 文章标题 category: 分类 tag:标签，可以有多个，需要换行，具体写法如下 excerpt:摘要 123tag:- 算法- leetcode","link":"/2022/04/17/%E9%9A%8F%E7%AC%94/blog%E8%BF%87%E7%A8%8B/"},{"title":"leetcode-两数之和","text":"leetcode 方法一：双指针在有序情况下，使用两侧双指针使两数之和为target！！ 时间复杂度是O(N); 123456789101112131415161718192021class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) { int n=numbers.size(); int l=0,r=n-1; vector&lt;int&gt;ans(2); while(l&lt;r){ int sum=numbers[l]+numbers[r]; if(sum==target){ ans[0]=l+1; ans[1]=r+1; return ans; } if(sum&lt;target) l++; else r--; } return ans; }}; 方法二：二分查找时间复杂度为O(NlogN) 1234567891011121314151617181920212223242526272829class Solution {public: int biSearch(vector&lt;int&gt;&amp; nums,int l,int r,int x){ while(l&lt;=r){ int mid=(l+r)/2; if(nums[mid]==x) return mid; if(nums[mid]&lt;x) l=mid+1; else r=mid-1; } return -1; } vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) { int n=numbers.size(); vector&lt;int&gt;ans(2); for(int i=0;i&lt;n;i++){ int x=target-numbers[i]; int pos=biSearch(numbers,i+1,n-1,x); if(pos!=-1){ ans[0]=i+1; ans[1]=pos+1; return ans; } } return ans; }};","link":"/2022/04/17/%E7%AE%97%E6%B3%95/leetcode-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E2%85%A1/"},{"title":"搜索插入位置","text":"leetcode 二分搜索左边界思想：不断缩小右边界 注意：要区分数组中有无重复元素的情况。 123456789101112131415161718192021class Solution {public: //等价于找到第一个大于等于targrt的元素的下标 int searchInsert(vector&lt;int&gt;&amp; nums, int target) { int l=0,r=nums.size()-1; int ans=nums.size();//有可能所有元素都小于target //[l,r]是搜索空间 while(l&lt;=r){ int mid=l+(r-l)/2; if(nums[mid]==target)//本体明确说明没有重复元素，才可以这样写 return mid; if(nums[mid]&gt;target){ ans=mid;//先把当前大于target的元素下标记下来，再去左侧找可能的更优解 r=mid-1; } else l=mid+1; } return ans; }}; 如果数组中有重复元素 12345678910111213141516171819class Solution {public: //等价于找到第一个大于等于targrt的元素的下标 int searchInsert(vector&lt;int&gt;&amp; nums, int target) { int l=0,r=nums.size()-1; int ans=nums.size();//有可能所有元素都小于target //[l,r]是搜索空间 while(l&lt;=r){ int mid=l+(r-l)/2; if(nums[mid]&gt;=target){//即使等于target了，有可能是重复元素，还要往左侧找 ans=mid;//先把当前大于target的元素下标记下来，再去左侧找可能的更优解 r=mid-1; } else l=mid+1; } return ans; }};","link":"/2022/04/17/%E7%AE%97%E6%B3%95/leetcode-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"},{"title":"日常编程心得","text":"2022-4 vector定义二维数组并初始化大小 方法一： 1vector&lt;&lt;vector&lt;int&gt; &gt;arr(m,vector&lt;int&gt;(n,0)); ​ 上述语句定义了一个m*n的二维数组arr，初始值为0 方法二： 12345678int m=10,n=5;vector&lt;vector&lt;int&gt; &gt;arr(m);//必须定义行数，列可以不定义for(int i=0;i&lt;m;i++){//初始化，或者直接赋值 for(int j=0;j&lt;n;j++){ arr[i].push_back(0); }} 报runtime error: reference binding to null pointer of type 'vector数组（一维或二维'可能原因 数组越界，在对vector初始化的时候没有初始化到合适大小，而在接下来的使用中使用了越界的下标 b.对于vector构建出来的二维数组没有进行空间的申请,比如有些返回类型为vector&lt;vector&lt;&gt;&gt;类型的函数，对于这个返回值vector表示的二维数组要先申请大小，否则使用下标访问就会报这类错误。 c++中int型i，要注意i*i的范围可能会溢出 小技巧：如何保持函数中第一个数组长度小于第二个","link":"/2022/04/17/%E9%9A%8F%E7%AC%94/%E6%97%A5%E5%B8%B8%E7%BC%96%E7%A8%8B%E5%BF%83%E5%BE%97/"},{"title":"下一个更大元素","text":"leetcode 本题用的是单调栈和哈希表 123456789101112131415161718192021class Solution {public: vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { unordered_map&lt;int,int&gt; hashmap; stack&lt;int&gt; st; for (int i = nums2.size() - 1; i &gt;= 0; --i) {//注意要倒序遍历 int num = nums2[i]; while (!st.empty() &amp;&amp; num &gt;= st.top()) {//pop处所有比num小的元素 st.pop(); } hashmap[num] = st.empty() ? -1 : st.top();//如果栈空说明没有比之大的元素 st.push(num); } vector&lt;int&gt; res(nums1.size()); for (int i = 0; i &lt; nums1.size(); ++i) { res[i] = hashmap[nums1[i]]; } return res; }};","link":"/2022/04/20/%E7%AE%97%E6%B3%95/leetcode-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%E2%85%A0/"},{"title":"所有奇数长度子数组的和","text":"leetcode 计算任意区间的区间和时，考虑前缀和 注意计算差分时的下标，即连续区间的大小 12345678910111213141516171819class Solution {public: int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) { int n=arr.size(),sum=0; vector&lt;int&gt;preSum(n); preSum[0]=arr[0]; for(int i=1;i&lt;n;i++) preSum[i]=preSum[i-1]+arr[i]; for(int i=0;i&lt;n;i++){//i是左边界 for(int j=i;j&lt;n;j+=2){//j是右边界 if(i==0) sum+=preSum[j]; else sum+=preSum[j]-preSum[i-1]; } } return sum; }};","link":"/2022/04/23/%E7%AE%97%E6%B3%95/leetcode-%E6%89%80%E6%9C%89%E5%A5%87%E6%95%B0%E9%95%BF%E5%BA%A6%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C/"},{"title":"快乐数","text":"leetcode 方法一：用哈希表来判断 1234567891011121314151617181920212223class Solution {public: bool isHappy(int n) { unordered_set&lt;int&gt;st; int p=n; while(true){ long long sum=0; //while用来计算每一轮新的sum while(p){ sum+=(p%10)*(p%10); p/=10; } if(st.find(sum)!=st.end())//无限循环的情况 return false; if(sum==1)//==1的情况 return true; st.insert(sum); p=sum; } return false; }}; 方法二： 用快慢指针 12345678910111213141516171819202122232425class Solution {public: int bitSquareSum(int n) { int sum = 0; while(n &gt; 0) { int bit = n % 10; sum += bit * bit; n = n / 10; } return sum; } bool isHappy(int n) { int slow = n, fast = n; do{ slow = bitSquareSum(slow); fast = bitSquareSum(fast); fast = bitSquareSum(fast); }while(slow != fast); return slow == 1; }};","link":"/2022/04/23/%E7%AE%97%E6%B3%95/leetcode-%E5%BF%AB%E4%B9%90%E6%95%B0/"},{"title":"反转字符串中单词","text":"leetcode 12345678910111213141516171819202122class Solution {public: string reverseWords(string s) { int n=s.size(); int i=0;//i用于遍历字符串 while(i&lt;n) { int start = i;//start为一个单词的左边界 while (i&lt;n &amp;&amp; s[i]!= ' ') //while循环用于找到右边界 i++; int l= start,r=i-1; //交换该单词 while(l&lt;=r){ swap(s[l],s[r]); l++; r--; } while(i&lt;n &amp;&amp; s[i]== ' ')//while循环用于跳过空格 i++; } return s; }};","link":"/2022/04/18/%E7%AE%97%E6%B3%95/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%8D%95%E8%AF%8D/"},{"title":"无重复字符的最长子串","text":"leetcode 方法一：利用set，时间复杂度为O(n) 12345678910111213141516171819class Solution {public: int lengthOfLongestSubstring(string s) { int n=s.size(),ans=0,l=0; unordered_set&lt;char&gt;st; for(int r=0;r&lt;n;r++){//r是窗口的右边界，在扩大右边界 //先看看有边界指向的元素能不能放到set中 while(st.find(s[r])!=st.end()){//在缩小左边界 //如果不能放，就从set中一次次删除左边界的元素，直到能放 st.erase(s[l]); l++; } //现在可以放了 st.insert(s[r]); ans=max(ans,r-l+1); } return ans; }};","link":"/2022/04/27/%E7%AE%97%E6%B3%95/leetcode-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"title":"南理工877历年初试真题","text":"重点冒泡排序直接插入排序归并排序简单选择排序二分查找真题编程题第一题2013年：求二叉树高度题目 编写算法求二叉树T的高度,数据结构用二叉链表表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464710-9//非递归算法//利用层序遍历int maxDepth(TreeNode* root) { if(root==NULL) return 0; queue&lt;TreeNode*&gt;que; queue&lt;TreeNode*&gt;temp; int h=0; que.push(root); //根节点入队 while(!que.empty()){ //队列不空的时候，让左右孩子进临时队列（如果存在），队头元素出队 while(!que.empty()){ TreeNode* t=que.front(); if(t-&gt;left!=NULL) temp.push(t-&gt;left); if(t-&gt;right!=NULL) temp.push(t-&gt;right); que.pop(); } //把临时队列里的元素再复制回去 while(!temp.empty()){ TreeNode*p=temp.front(); que.push(p); temp.pop(); } h++; } return h; } //递归算法 int Btdepth(TreeNode *T){ if(T==NULL) return 0; int l=Btdepth(T-&gt;lchild); int r=Btdepth(T-&gt;rchild); if(l&gt;r) return l+1; else return r+1;} leetcode类似题目 剑指offer55 考察知识点 二叉树、递归 第二题2014年题目 二叉树采用二叉链表作为存储结构，链表中结点的结构为： 12345typedef struct BitNode{ int data; biteNode*lchid,*rchild;}bitNode; 构造一个递归算法计算二叉树中值等于x的结点的个数。函数原型为countx(bitNode *t, int x) 12345678910int countx(bitNode*t,int x){ if(t==NULL) return 0; int l=countx(t-&gt;lchild); int r=count(t-&gt;rchild); if(t-&gt;data==x) return l+r+1; else return l+r;} 非递归算法 1遍历 第三题2015-1题目 设计计算二叉树中所有节点值之和的算法 1234567891011121314151617181920212223242526//递归int sum(Node* root){ if(root==NULL) return 0; int l=sum(root-&gt;lchild); int r=sum(root-&gt;rchild); return root-&gt;data+l+r;} //非递归int sum(NOde* root){ int ans=0; Node*p=root; stack&lt;Node*&gt;st; while(!st.empty() || p!=NULL){ while(p!=NULL){ st.push(p); p=p-&gt;lchild; ans=ans+st.top()-&gt;data; } p=st.top()-&gt;rchild; st.pop(); }} 第四题2015-2：顺序表中奇数挪到偶数前题目 设计将一个顺序存储的线性数表中所有奇数移动到所有偶数之前的算法 12345678910111213141516171819202122232425struct SeqList{ int* L; int len,maxLen;};void swap(SeqList L,int i,int j){ int temp=L.data[i]; L.data[i]=L.data[j]; L.data[j]=temp;}void move(SeqList L){ int i=0,j=len-1; while(i&lt;j){ while(i&lt;j &amp;&amp; L.data[i]%2==1) //从前往后找到第一个偶数 i++; while(i&lt;j &amp;&amp; L.data[j]%2==0) //从后往前找到第一个奇数 j--; //错了 if(i&lt;j) //防止全部都是奇数或者全是偶数，导致指针越界 swap(L,i,j); }} 12345678910111213141516171819202122struct SeqList{ int *data; int len,maxlen;}void swap(SeqList L,int i,int j){ int temp=L.data[i]; L.data[i]=L.data[j]; L.data[j]=temp;}void move(SeqList L){ int i=0,j=L.len-1; while(i&lt;j){ //循环 while(i&lt;j &amp;&amp; L.data[i]%2==1) //从左往右，找到第一个偶数的时候，停下来 i++; while(i&lt;j &amp;&amp; L.data[j]%2==0) //从右往左，找到第一个奇数的时候，停下来 j--; if(i&lt;j) swap(L,i,j); } } 小余的代码 12345678910111213141516171819void swap(int arr[],int l,int r){ int t=arr[l]; arr[l]=arr[r]; arr[r]=t;}/*将数组中的奇数放前边，偶数放后边*/void moveOddAndEven(int arr[],int n){ int l=0,r=n-1; while(l&lt;r){ while(l&lt;r &amp;&amp; arr[l]%2!=0) l++; while(l&lt;r &amp;&amp; arr[r]%2==0) r--; if(l&lt;r) swap(arr,l,r); }} 第五题2015-3题目 设计算法判断单链表中元素是否递增 12345678910111213141516171819202122//不带头结点的bool check(Node* L){ Node*p=L; if(p==NULL) return true; while(p-&gt;next!=NULL){ if(p-&gt;data&gt;p-&gt;next-&gt;data) return false; p=p-&gt;next; } return true;}//递归bool check(Node* L){ if(L==NULL || L-&gt;next==NULL) return true; if(L-&gt;data&gt;L-&gt;next-&gt;data) return false; return check(L-&gt;next);} 小余的代码 123456789101112131415161718/*判断单链表元素是否递增*/bool check(Node*head){ if(!head) return true; while(head-&gt;next){ if(head-&gt;next-&gt;data&lt;head-&gt;data) return false; head=head-&gt;next; } return true;}/*判断单链表元素是否递增,递归写法*/bool check2(Node*head){ if(!head || !head-&gt;next) return true; return check2(head-&gt;next) &amp;&amp; head-&gt;next-&gt;data&gt;=head-&gt;data;} 第六题2017：删除单循环链表中重复结点值题目 已知一个带头节点的单循环链表的数据结构定义如下： 1234typedef struct lnode{ int data; lnode*next;}lnode; 假设链表中可能存在多个值相同的结点，请设计一个算法，删除链表中值重复的其他节点（注意保留第一个值得节点），使得链表中无值相同的结点。函数原型为void deletex(lnode * &amp;head) 12345678910111213141516171819202122232425void deletex(lnode* &amp;head){ lnode*p=head-&gt;next; while(p!=head){ lnode*pre=p; lnode* t=p-&gt;next; int key=p-&gt;data; //t往后走一圈，检查有没有跟key重复的 while(t!=head){ if(t-&gt;data==key){ //重复了，删掉该结点 pre-&gt;next=t-&gt;next; t=t-&gt;next; }else{ //不重复，继续往后走 pre=t; t=t-&gt;next; } } p=p-&gt;next; }} 12345678910111213141516171819/*单循环链表（带头节点）中，删除链表中值重复的其他节点（注意保留第一个值得节点），使得链表中无值相同的结点*/void deletex(Node* &amp;head){ Node*start=head-&gt;next; while(start!=head){ //把所有和start值相同的节点删除 Node*t=start-&gt;next; Node*pre=start; while(t!=head){ if(t-&gt;data==start-&gt;data){ pre-&gt;next=t-&gt;next; t=t-&gt;next; }else{ pre=pre-&gt;next; t=pre-&gt;next; } } start=start-&gt;next; }} 第七题2018：判断图两个顶点是否连通题目 假设一个不带权的无向图采用邻接表G进行存储，设计一个算法FindaPath(G, u, v, &amp;has)，判断该图中顶点u到顶点v是否连通，如果连通，has为1，否则为0，在调用该算法之前has置初值为0 123456789101112131415161718192021222324252627282930//date:10-22struct Arc{ int key; //int len; //权值 Arc* next;};struct Vertex{ int key; Arc* firstArc;};//图//Vertx* adj[MaxSize];struct Graph{ int e; int n; vertex adj[MaxSize];};void FindaPath(Graph G,int u,int v,int &amp;has){ Arc*p=adj[u].firstArc; while(p!=NULL){ if(p-&gt;key==v){ has=1; return; } p=p-&gt;next; } has=0;} 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#define MAX 1000using namesapce std;//边表的结点struct Arc{ int key; //几号顶点 Arc* next; //int info; //权值}//顶点表中的顶点struct Vertex{ int key; //顶点号 Arc* firstArc; //指向边表的第一个结点}//邻接表struct Graph{ int n; //n个结点 int e; //e条边 Vertext adj[MAX]; //顶点表}void FindaPath(Graph G, int u,int v,int &amp;has) { Arc* p=G.adj[u].firstArc; while(p!=NULL){ if(p-&gt;key==v){ has=1; return; } p=p-&gt;next; } has=0;} 小余的代码 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#define MAX 1000using namespace std;//图的邻接表的定义：/*边表的节点*/struct ArcNode { int vertex; //几号顶点, 或者变量名写成adjvex，即adjacent vertex 相邻的顶点 ArcNode *next; //int info; //带权的可以记录权值};/*数组顶点表中的顶点*/struct VNode { int data; //该顶点存储的数据 ArcNode *firstArc; //};/*邻接表*/struct Graph { int N; //一共有N个节点 int e; //一共e条边 VNode AdjList[MAX]; //顶点表};void findPath(Graph G,int u,int v,bool &amp;has ){ ArcNode*p=G.AdjList[u].firstArc; while(p!=NULL){ if(p-&gt;vertex==v) { has=1; return; } p=p-&gt;next; }} 答案 南理工ppt对邻接表的定义 第八题题目 非递归查找叶子结点（题目不完整，查找个数？） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//递归int findleaf(Node* root){ //第一种情况，指针为空 if(root==NULL) return 0; //root是叶子结点 if(root-&gt;lchild==NULL &amp;&amp; root-&gt;rchild==NULL) return 1; //root不是叶子结点 int l=findleaf(root-&gt;lchild); int r=findleaf(root-&gt;rchild); return l+r;}//非递归，层序遍历int findleaf1(Node*root){ queue&lt;Node*&gt;que; Node*p=root; que.push(p); int count=0; while(!que.empty(){ Node*first=que.front(); que.pop(); if(first-&gt;lchild!=NULL) que.push(first-&gt;lchild); if(first-&gt;rchild!=NULL) que.push(first-&gt;rchild); if(first-&gt;lchild==NULL &amp;&amp; first-&gt;rchild==NULL) count++; } return count; }//data:10-18 int findleaf(Node* root){ //第一种情况，指针为空 if(root==NULL) //第一种情况 return 0; if(root-&gt;lchild!=NULL &amp;&amp; root-&gt;rchild==NULL) //第二种情况 return findleaf(root-&gt;lchild); if(root-&gt;lchild!=NULL &amp;&amp; root-&gt;rchild!=NULL) //第三种情况 return findleaf(root-&gt;rchild); //root是叶子结点 if(root-&gt;lchild==NULL &amp;&amp; root-&gt;rchild==NULL) return 1; //root不是叶子结点 return findleaf(root-&gt;lchild)+findleaf(root-&gt;rchild);//第四种情况，第四种情况包含第二三种情况，所以第二三种情况可以删去} 思路 非递归，则考虑前中后序遍历和层序遍历。 第九题2019-2：合并两个递增链表，不允许元素重复题目 合并两个递增链表a和b，最后存在a中，不允许同样的元素存在 类似题目 leetcode 21 小余的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;using namespace std;struct Node { int data; Node *next;};/*合并ab两个递增链表，最后存在a中，不允许同样的元素存在*/void merge(Node* &amp;a, Node* &amp;b) { Node *t=(Node*)malloc(sizeof(Node)); //创建一个带头节点的临时链表 t-&gt;next=NULL; Node*p1=a,*p2=b,*p3=t; while(p1!=NULL &amp;&amp; p2!=NULL){ int newData; //用来接收p1和p2中较小的数值 if(p1-&gt;data&lt;p2-&gt;data){ //如果p1小，p1的值给newdata，如何p1往后走 newData=p1-&gt;data; p1=p1-&gt;next; } else if(p1-&gt;data&gt;p2-&gt;data){ //如果p2小，p2的值给newdata，如何p2往后走 newData=p2-&gt;data; p2=p2-&gt;next; } else{ newData=p1-&gt;data; //如果p1和p2一样大，p1和p2任意的值给newdata，p1和p2都往后走 p1=p1-&gt;next; p2=p2-&gt;next; } //临时链表增加一个节点 //每次把newdata插入到临时链表的末尾 p3-&gt;next=(Node*)malloc(sizeof(Node)); p3=p3-&gt;next; p3-&gt;data=newData; p3-&gt;next=NULL; } while(p1!=NULL){ //若p2已经空了，用p1和p3比较。若p1有重复元素，就会导致p1和p3参与比较的结点值相等，就直接让p1后移 //挪到不相等的时候，p1的值只可能会比p3大，将P1的值插入p3 if(p3-&gt;data&lt;p1-&gt;data){ //p3的值不可能比p1的值大 p3-&gt;next=(Node*)malloc(sizeof(Node)); p3-&gt;next-&gt;data=p1-&gt;data; p3=p3-&gt;next; } p1=p1-&gt;next; } while(p2!=NULL){ if(p3-&gt;data&lt;p2-&gt;data){ p3-&gt;next=(Node*)malloc(sizeof(Node)); p3-&gt;next-&gt;data=p2-&gt;data; p3=p3-&gt;next; } p2=p2-&gt;next; } p3-&gt;next=NULL; a=t-&gt;next; //将结果存在a链中}//上次写的日期： 第十题2019-1*题目 合并两个递增有序的链表为一个新的链表，删除重复元素 1234567891011121314151617181920212223242526272829303132333435363738```## 第十一题2020-2***题目**非递归判断一棵树是否为排序二叉树，求时间复杂度```c//书写日期：10-8//二叉排序树的中序遍历序列是递增的bool check(TreeNode* root){ stack&lt;TreeNode*&gt;st; TreeNode*p=root; //vector&lt;int&gt;ans; int min=-99999; //不可能达到的最小值,int 4字节 32位 111111111...11 while(p!=NULL || !st.empty()){ while(p!=NULL){ st.push(p); p=p-&gt;lchild; } //ans.push_back(st.top()-&gt;data); if(st.top()-&gt;data&lt;min) //如果栈顶元素更小，说明不是二叉排序树 return fasle; else //如果栈顶元素比min大，说明目前为止中序遍历序列是递增的，继续往后检验 min=st.top()-&gt;data; p=st.top()-&gt;rchild; st.pop(); } /* for(int j=0;j&lt;ans.size()-1;j++){ if(ans[j]&gt;ans[j+1]) return false; }*/ return true;} 思路 中序遍历序列是否递增 第十二题2020-3：判断图是否有回路题目 图的邻接矩阵存储，写出数据结构，非递归算法（邻接表）判断无向图是否有回路。并说明邻接表和邻接矩阵的优缺点 123456789101112131415161718192021222324252627282930313233343536373839404142434445//date:10-22struct Arc{ int key; Arc* next;};struct Vertex{ int key; Arc* firstArc;};//节点号从1开始bool checkCircle(Vertex adj[n]){ int inDegree[n]; //记录各节点入度的数组，初始值全为0 for(int i=0;i&lt;n;i++){ //结点号从1开始 Arc*p=adj[i].firstArc; while(p!=NULL){ inDegree[p-&gt;key-1]++; p=p-&gt;next; } } int count=0; //记录删除结点的个数 stack&lt;int&gt;st; //记录入度为0的节点号 for(int i=0;i&lt;n;i++){ //数组下标从0开始 if(inDegree[i]==0) st.push(i+1); } while(!st.empty()){ //逻辑删除入度为0的结点及其发出的边 int t=st.top(); st.pop; count++; Arc*q=adj[t-1].firstArc; while(q!=NULL){ inDegree[q-&gt;key-1]--; if(inDegree[q-&gt;key-1]==0) st.push(q-&gt;key); q=q-&gt;next; } } if(count&lt;n) return true; else return false;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112//日期：10-8#include &lt;iostream&gt;#include &lt;stack&gt;#define MaxSize 30 //顶点表的最大长度using namespace std;//边表结点（弧）struct Arc{ int key; int len; Arc* next;};//顶点结点struct Vertex{ int key; Arc* next;};//图struct Graph{ Vertex adj[MaxSize]; int n; //顶点个数 int e; //边的个数};//图：邻接矩阵表示法struct Graph2{ int edge[N][N]; int e,n; //边和顶点的数量};//判断邻接表是否有环路：借鉴拓扑排序的思想bool checkCircle(Graph G){ //记录所有顶点的入度 int inDegree[N]; //默认数组初值为0，表示未访问 /* for(int i=0;i&lt;N;i++) //初始化，考试时直接用上述注释写就可以 inDegree[i]=0;*/ for(int i=0;i&lt;N;i++){ Arc*p=G.arr[i].next; while(p!=NULL){ inDegree[p-&gt;key]++; p=p-&gt;next; } } //判断是否有回路 stack&lt;int&gt;st; //记录入度为0（无向图则是度为1）的顶点号 //遍历inDegree，初始化st for(int i=0;i&lt;N;i++){ if(inDegree[i]==0) st.push(i); } int count=0; //删除的顶点的个数 while(!st.empty()){ //弹出一个栈顶元素 int t=st.top(); st.pop(); count++; //删除该结点以及与其指向的边（逻辑上的删除，通过减少其他结点的入度来删除的） Arc*p=G.adj[t].next; while(p!=NULL){ inDegree[p-&gt;key]--; //如果入度变成0，则要入栈 if(inDegree[p-&gt;key]==0) st.push(p-&gt;key); p=p-&gt;next; } } //如果循环完了，还存在顶点/边，则说明有回路 if(count&lt;N) return true; //表示有回路 else return false;}//data:10-18，小余的代码//图的深度优先遍历，判断环(只能有向图)bool checkCircle2(Vertex adj[],int v0){ if(visited[v0]==1){ cout&lt;&lt;&quot;now visit &quot;&lt;&lt;v0&lt;&lt;&quot;,conflict!&quot;&lt;&lt;endl; return true; } visit(v0); visited[v0]=1; Arc*p=adj[v0].firstArc; while(p!=NULL){ bool t=checkCircle2(adj,p-&gt;key); if(t) return true; //有环，直接返回true p=p-&gt;next; } return false; //v0后序路径都检查过没有环，则返回false}邻接矩阵：优点：是可以快速判断两个顶点之间是否存在边，可以快速添加边或者删除边，方便计算结点的度；缺点：不适合存储稀疏图邻接表：缺点：不方便对入度结点进行操作，只能依次遍历整个邻接表；对于无向图，如果需要删除一条边，就需要在两个链表上查找并删除。优点：节省存储空间，只存储实际存在的边 第十三题2021-1：图的深度优先遍历题目 深度优先遍历中需要数据结构k的帮助，请问k是什么结构，有何作用及初值；写出图的深度优先遍历dfs(g, n, k, v0) ，其中n是结点数，v0是开始节点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//10-24#include &lt;iostream&gt;#include &lt;stack&gt;#define N 8using namespace std;//用栈实现深度优先遍历struct Arc { int key; Arc *next; Arc() : key(-1), next(NULL) {} Arc(int k) : key(k), next(NULL) {}};struct Vertex { int key; Arc *firstArc; Vertex(int k) : key(k), firstArc(NULL) {} Vertex() : key(-1), firstArc(NULL) {}};void visit(int k) { cout &lt;&lt; k &lt;&lt; endl;}/*无向图，有向图，均可*/void dfs(Vertex adj[], int n, int v0) { bool visited[n]; for (int i = 0; i &lt; n; i++) visited[i] = false; stack&lt;int&gt; st; visit(v0); visited[v0]=true; st.push(v0); while (!st.empty()) { int t = st.top(); Arc *p = adj[t].firstArc; int K = -1; while (p != NULL) { if (!visited[p-&gt;key]) { K = p-&gt;key; break; } p = p-&gt;next; } //如果t的后继都访问过了，则弹出 if (K == -1) { st.pop(); } //否则，访问未访问过的后继 else { visit(K); visited[K]=true; st.push(K); //放进栈的目的是，访问其后继 } }}//添加Arcvoid addArc(Vertex arr[], int k, int s) { if (arr[k].firstArc == NULL) arr[k].firstArc = new Arc(s); else { Arc *p = arr[k].firstArc; while (p-&gt;next != NULL) p = p-&gt;next; p-&gt;next = new Arc(s); }}int main() { Vertex arr[N]; for (int i = 0; i &lt; N; i++) { arr[i].key = i; } addArc(arr, 1, 0); addArc(arr, 1, 2); addArc(arr, 2, 3); addArc(arr, 2, 4); addArc(arr, 4, 5); addArc(arr, 5, 6); addArc(arr, 3, 7); dfs(arr, N, 1); return 0;} 123456789101112131415161718192021222324252627282930313233343536373839404142//日期：10-16k是栈，对节点进行后进先出的访问，struct stack{ int data[MaxSize]; int top=-1; //初始值为-1};void dfs(Vertex adj[],int n,stack k,int v0){ int visit[n]; //标记是否访问，初值均为0 visit[v0]=1; //表示V0已访问 k.push(v0); while(!k.empty()){ //找栈顶元素的一条路径 Arc*p=adj }}//递归进行深度优先遍历bool visited[n]; //初值为falsevoid dfs(Vertex adj[],int v0){ visited[v0]=true; visit(v0); //访问该结点 Arc*p=adj[v0].firstArc; while(p!=NULL){ if(!visited[p-&gt;key]){ dfs(adj,p-&gt;key); } }}void DFSTraverse(Vertex adj[],int n){ for(int i=0;i&lt;n;i++){ if(!visited[i]) dfs(adj,i);} 第十四题2021-2：图中删除指定边题目 删除指定边delete(adj, u, v) 说明：图用邻接表存储， 数组起点为0， 顶点标号起点1， &lt;u, v&gt;存在，不用检测 123456789101112131415161718192021//date:10-22struct Arc{ int key; Arc* next;};struct Vertex{ int key; Arc* firstArc;};void delete(Vertex* adj[n],int u,int v){ Arc*p=adj[u-1].firstArc; if(p-&gt;key==v){ adj[u-1].firstArc=p-&gt;next; return; } while(p-&gt;next-&gt;key!=v) p=p-&gt;next; p-&gt;next=p-&gt;next-&gt;next; return; } 1234567891011121314151617181920212223242526272829303132333435363738//日期：10-14#define MaxSize 20//边表节点struct Arc{ int key; //int len; Arc* next;}//顶点结点struct Vertex{ int key; Arc* firstArc;}//图struct Graph{ Vertex arr[MaxSize]; int n; int e;}void delete(Graph &amp;adj,int u,int v){ Arc*p=adj.arr[u-1].firstArc; if(p-&gt;key==v) adj.arr[u-1].firstArc=p-&gt;next; //注意这里不是p=p-&gt;next else{ while(p-&gt;next-&gt;key!=v) p=p-&gt;next; p-&gt;next=p-&gt;next-&gt;next; } return; } 123456789101112131415161718192021//小余写的//函数：删除a指向b的边void deleteArc(Graph&amp;adj,int a,int b){ Node*p=adj.arr[a].next; //指针p，指向节点a的边表第一个节点 //如果第一个节点就是b if(p-&gt;key==b){ adj.arr[a].next=NULL; //错误的哟 } else{ while(p-&gt;next-&gt;key!=b) p=p-&gt;next; p-&gt;next=p-&gt;next-&gt;next; //删除边 }}void declar(Graph &amp;adj,int u,int v){ deleteArc(adj,u,v); deleteArc(adj,v,u);} 第十五题2021-3：二叉树中度为1的节点数题目 递归求二叉树中度为1的结点数 int count(p) 结点有数据域， 左孩子域，右孩子域，遍历，p为根结点 123456789101112131415//日期 10-17/10-18int count(Node* p){ if(p==NULL) //p为空 return 0; int l=count(p-&gt;lchild); int r=count(p-&gt;rchild); if(p-&gt;lchild!=NULL &amp;&amp; p-&gt;rchild==NULL) //p不空，但p的左孩子不空，右孩子空，递归访问左孩子 return l+1; else if(p-&gt;lchild==NULL &amp;&amp; p-&gt;rchild!=NULL) //p不空，但p的左孩子空，右孩子不空，递归访问右孩子 return r+1; return l+r; //p的左右孩子都不空，递归访问左孩子和右孩子，加和 } 12345678910111213141516171819202122232425262728//日期：10-8//宝宝写的，错误，对比第8题int count(TreeNode*p){ if(p==NULL) return 0; if(p-&gt;lchild!=NULL &amp;&amp; p-&gt;rchild==NULL || p-&gt;lchild==NULL &amp;&amp; p-&gt;rchild!=NULL) return 1; int l=count(p-&gt;lchild); int r=count(p-&gt;rchild); return l+r;} //小余写的//计算以p位根节点的树，有多少度为1的结点int count(TreeNode*p){ if(p==NULL) return 0; //度为1的两种情况 if(p-&gt;left!=NULL &amp;&amp; p-&gt;right==NULL) return count(p-&gt;left)+1; else if(p-&gt;left==NULL &amp;&amp; p-&gt;right!=NULL) return count(p-&gt;right)+1; //度为0或度为2 return count(p-&gt;left)+count(p-&gt;right); } 第十六题2019题目 已知一个带有头节点的单链表，在第一个关键字为X的后面插入Y，如果没有X，则在链尾插入Y 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//日期：10-17typedef struct node{ int data; Node*next;}node void insert_y(node* head,int x,int y){ node*p=head; //创建节点 node*t=(node*)malloc(sizeof(node)); t-&gt;data=y; while(p-&gt;next!=NULL){ if(p-&gt;next-&gt;data!=x) //寻找值为x的结点的前驱 p=p-&gt;next; else{ //找到值为x的结点的前驱，进行插入操作 p=p-&gt;next; t-&gt;next=p-&gt;next; p-&gt;next=t; return; } } t-&gt;next=NULL; p-&gt;next=t;}//小余写的void insert_y(node* head,int x,int y){ node*p=head; while(p-&gt;next!=NULL &amp;&amp; p-&gt;next-&gt;data!=X) p=p-&gt;next; //创建结点 node*t=(node*)malloc(sizeof(node)); t-&gt;data=y; //如果走到末尾 if(p-&gt;next==NULL){ t-&gt;next=NULL; p-&gt;next=t; } //如果走到p-&gt;next是X else{ p=p-&gt;next; t-&gt;next=p-&gt;next; p-&gt;next=t; }} 期末题编程题2020年1.已知一单循环链表head存放一组整型数（链表中可能有多个相同元素），构造算法删除链表中一些元素使得链表中无相同元素，并返回具有相同值元素的个数。函数原型为int DeleteNode(lnode *&amp;head)。例如：初始序列：20 30 6 20 18 40 60 6 70 18结束序列：20 30 6 18 40 60 70返回值：3 结点类型定义如下： 1234typedef struct lnode{ int data; lnode*next;}lnode; 12345678910111213141516171819202122232425//date:10-18//默认有头结点int DeleteNode(lnode* &amp;head){ lnode* p=head-&gt;next; int count=0; while(p!=head){ lnode* pre=p; //用来删除具有相同元素的结点 lnode* t=p-&gt;next; int key=p-&gt;data; while(t!=head){ if(t-&gt;data==key){ t=t-&gt;next; pre-&gt;next=t; count++; } else{ pre=pre-&gt;next; t=t-&gt;next; } } p=p-&gt;next; } return count;} 2.已知二叉链表数据关系定义如下： 1234typedef struct bitnode{ int data; bitnode*lt,*rt;}bitnode; 构造一个判断两个二叉树是否相似（指两棵树模式形同，结点的值可以不同）的递归算法，若相似返回1，否则返回0。函数原型为int IsAlike(bitnode*t,bitnode*s) 12345678910111213141516171819202122232425//date:10-17，错误！！！//判断分别以s和t为根节点的二叉树是否相似int IsAlisk(bitnode* t,binode* s){ if(t==NULL &amp;&amp; s==NULL) return 1; if((t-&gt;lt==NULL &amp;&amp;t-&gt;rt!=NULL) &amp;&amp; (s-&gt;lt!=NULL&amp;&amp; s-&gt;rt==NULL) || (t-&gt;lt!=NULL &amp;&amp; t-&gt;rt==NULL) &amp;&amp; (s-&gt;lt==NULL &amp;&amp; s-&gt;rt!=NULL) return 0; if(t-&gt;lt!=NULL &amp;&amp; t-&gt;rt==NULL &amp;&amp; s-&gt;lt!=NULL &amp;&amp; s-&gt;rt==NULL) return IsAlike(t-&gt;lt,s-&gt;lt); if(t-&gt;lt==NULL &amp;&amp; t-&gt;rt!=NULL &amp;&amp; s-&gt;lt==NULL &amp;&amp; s-&gt;rt!=NULL) return IsALike(t-&gt;rt,s-&gt;rt); return IsAlike(t-&gt;lt,s-&gt;lt) &amp;&amp; IsALike(t-&gt;rt,s-&gt;rt); } //data:10-18int IsAlisk(bitnode* t,binode* s){ if(t==NULL &amp;&amp; s==NULL) //s和r都空，相似 return 1; if(!(t!=NULL &amp;&amp; s!=NULL)) //s或t一个空一个不空，不相似 return 0; if(t!=NULL &amp;&amp; s!=NULL){ //s和t都不空，递归访问其左右孩子 return IsAlike(t-&gt;left,s-&gt;left) &amp;&amp; IsAlike(t-&gt;right,s-&gt;right); }} 123456789101112//小余的代码int isAlike(bitnode*t,bitnode*s){ if(t==NULL &amp;&amp; s==NULL) //都为空 return 1; if(!( t!=NULL &amp;&amp; s!=NULL )) //其中一个为空 return 0; //两个都不空 if( isAlike(t-&gt;left,s-&gt;left) &amp;&amp; isAlike(t-&gt;right,s-&gt;right) ) return 1; else return 0;} 2018 1234567891011121314151617181920212223242526//date:10-19//非递归BITNode* FindMin(BITNode* t){ if(t==NULL) return NULL; while(t-&gt;lchild!=NULL) t=t-&gt;lchild; return t;}//递归BITNode* FindMin(BITNode* t){ if(t-&gt;lchild==NULL) return t; return BITNode(t-&gt;lchild);}//小余写的BitNode* FindMin(BitNode*t){ while(t-&gt;left!=NULL) t=t-&gt;left; return t;} 1234567891011121314151617181920212223242526//date:10-19//值严格递增void intersection(lnode* &amp;ha,lnode* hb){ lnode* temp=(lnode*)malloc(sizeof(lnode)); //创建一个临时单循环链表 temp-&gt;next=NULL; lnode*a=ha-&gt;next; lnode*b=hb-&gt;next; lnode*c=temp; while(a!=ha &amp;&amp; b!=hb){ //当ha和hb都没遍历完时 if(a-&gt;data&lt;b-&gt;data) a=a-&gt;next; else if(a-&gt;data&gt;b-&gt;data) b=b-&gt;next; else{ c-&gt;next=(lnode*)malloc(sizeof(lnode)); c=c-&gt;next; c-&gt;data=a-&gt;data; c-&gt;next=NULL; a=a-&gt;next; b=b-&gt;next; } } ha-&gt;next=temp-&gt;next;} 12345678910111213141516171819202122232425//小余的代码/*严格单调递增情况下*/void intersection(lnode*&amp;ha,lnode*hb){ //注意第一个参数加了引用 lnode*hc=(lnode*)malloc(sizeof(lnode)); 创建新链接收相同节点 hc-&gt;next=NULL; lnode*p1=ha-&gt;next,*p2=hb-&gt;next,*p3=hc; while(p1!=ha &amp;&amp; p2!=hb){ if(p1-&gt;data==p2-&gt;data){ p3-&gt;next=(lnode*)malloc(sizeof(lnode)); p3=p3-&gt;next; p3-&gt;data=p1-&gt;data; p3-&gt;next=NULL; p1=p1-&gt;next; p2=p2-&gt;next; } else if(p1-&gt;data&lt;p2-&gt;data){ p1=p1-&gt;next; }else{ p2=p2-&gt;next; } } ha-&gt;next=hc-&gt;next;} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//date:10-19//严格单调递增int union(lnode* &amp;ha, lnode* hb){ lnode* hc=(lnode*)malloc(sizeof(lnode)); hc-&gt;next=NULL; lnode*p1=ha-&gt;next; lnode*p2=hb-&gt;next; lnode*p3=hc; int count=0; while(p1!=ha &amp;&amp; p2!=hb){ lnode* p3-&gt;next=(lnode*)malloc(sizeof(lnode)); p3=p3-&gt;next; p3-&gt;next=NULL; if(p1-&gt;data&lt;p2-&gt;data){ p3-&gt;data=p1-&gt;data; p1=p-&gt;next; } else if(p1-&gt;data&gt;p2-&gt;data){ p3-&gt;data=p2-&gt;data; p2=p2-&gt;next; } else{ p3-&gt;data=p1-&gt;data; p1=p-&gt;next; p2=p2-&gt;next; } count++; } while(p1!=ha){ lnode* p3-&gt;next=(lnode*)malloc(sizeof(lnode)); p3=p3-&gt;next; p3-&gt;data=p1-&gt;data; p3-&gt;next=NULL; p1=p1-&gt;next; count++; } while(p2!=hb){ lnode* p3-&gt;next=(lnode*)malloc(sizeof(lnode)); p3=p3-&gt;next; p3-&gt;data=p2-&gt;data; p3-&gt;next=NULL; p2=p2-&gt;next; count++; } ha-&gt;next=p3-&gt;next; return count;} 2016 1234567891011//date:10-19//递归int high(BTNode* BT){ if(BT==NULL) return 0; int l=high(BT-&gt;lt); int r=high(BT-&gt;rt); if(l&gt;r) return l+1; return r+1;} 12345678910111213141516171819//date:10-20void insertxy(Lnode* &amp;head,int x,int y){ Lnode* p=head; Lnode* t=(Lnode*)malloc(sizeof(Lnode)); t-&gt;data=y; while(p-&gt;next!=NULL){ p=p-&gt;next; if(p-&gt;data!=x) p=p-&gt;next; else{ t-&gt;next=p-&gt;next; p-&gt;next=t; return; } } p-&gt;next=t; t-&gt;next=NULL; return;} 12345678910111213141516171819202122232425262728293031//date:10-20//方法一void rangdelete(Lnode* &amp;head,int min,int max){ Lnode*p=head; Lnode*pre=p; while(p-&gt;next!=head){ p=p-&gt;next; if(p-&gt;data&gt;min &amp;&amp; p-&gt;data&lt;max){ pre-&gt;next=p-&gt;next; p=p-&gt;next; } else{ pre=pre-&gt;next; p=p-&gt;next; } } }//方法二:利用值非递减，小余写的void rangdelete(Lnode* &amp;head,int min,int max){ Lnode*p=head; //找到最后一个值比min小的结点 while(p-&gt;next!=head &amp;&amp; p-&gt;next-&gt;data&lt;=min) p=p-&gt;next; if(p-&gt;next==head) return; Lnode*p2=p-&gt;next; //找到第一个大于等于max的结点或者是头结点（说明p后面的所有节点值全在min和max之间） while(p2!=head &amp;&amp; p2-&gt;data&lt;max) p2=p2-&gt;next; p-&gt;next=p2;} 2015 1234567891011121314151617181920212223//date:10-22//带头结点int CountA(LNode* L,ElemType a){ LNode*p=L; int count=0; while(p-&gt;next!=NULL){ if(p-&gt;next-&gt;data&gt;a) count++; p=p-&gt;next; } return count;}//不带头结点int CountA(LNode* L,ElemType a){ LNode*p=L; int count=0; while(p!=NULL){ if(p-&gt;data&gt;a) count++; p=p-&gt;next; } return count;} 12345678910111213141516171819202122//date:10-22void difference(Node* heada,Node* headb,int &amp;n){ Node*a=heada; Node*b=headb; int n=0; while(a-&gt;next!=NULL &amp;&amp; b-&gt;next!=NULL){ if(a-&gt;next-&gt;data&lt;b-&gt;next-&gt;data){ a=a-&gt;next; n++; } else if(a-&gt;next-&gt;data&gt;b-&gt;next-&gt;data) b=b-&gt;next; else{ a-&gt;next=a-&gt;next-&gt;next; b=b-&gt;next; } } while(a-&gt;next!=NULL){ n++; p=p-&gt;next; }} 2014*看王道视频，写代码 123 1234567//date:10-26//第二题int BTreeNodes(Node* p){ if(p==NULL) return 0; return 1+BTreeNodes(t-&gt;lchild)+BTreeNodes(p-&gt;rchild);} 12345678910111213141516171819202122232425262728293031//小余的代码struct LinkQueue{ Node*f,*r;}//队列初始化void init(LinkQueue&amp;que){ que.f=(Node*)malloc(sizeof(Node)); que.r=que.f; que.r-&gt;next=NULL;}//入队void push(LinkQueue&amp;que,int x){ Node*t=(Node*)malloc(sizeof(Node)); t-&gt;data=x; t-&gt;next=NULL; que.r-&gt;next=t;}//出队void pop(LinkQueue&amp;que){ if(que.f-&gt;next==NULL) //队列为空 return; que.f-&gt;next=que.f-&gt;next-&gt;next;}//判断队空bool Empty(LinkQueue que){ return que.f-&gt;next==NULL;} 2013 12345678910111213141516171819202122232425date:10-26//第一题 struct Arc{ int key; Arc*next;};struct Vertex{ int key; Arc* firstArc;};//数组[]可以不写东西void InsertArc(Vertex adj[],int u,int v,int n){ Arc*p=adj[u-1].firstArc; Arc*t=(Arc*)malloc(sizeof(Arc)); t-&gt;key=v; t-&gt;next=NULL; if(p!=NULL) adj[u-1].firstArc=t; else{ while(p-&gt;next!=NULL) p=p-&gt;next; p-&gt;next=t; } return;} 123456789101112131415161718192021222324252627282930313233343536//日期：10-14#define MaxSize 20 //图的顶点数组的最大长度#include &lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;//边表结点struct Arc{ int key; //int len; Arc* next;};//顶点结点struct Vertex{ int key; Arc* firstArc;};void addArc(Vertex adj[],int u,int v){ Arc* p=adj[u-1].firstArc; if(p==NULL){ //p-&gt;next=(Arc*)malloc(sizeof(Arc)); //@todo 错误！！！ adj[u-1].firstArc=(Arc*)malloc(sizeof(Arc)); adj[u-1].firstArc-&gt;key=v; adj[u-1].firstArc-&gt;next=NULL; } else{ while(p-&gt;next!=NULL) p=p-&gt;next; p-&gt;next=(Arc*)malloc(sizeof(Arc)); p-&gt;next-&gt;key=v; p-&gt;next-&gt;next=NULL; } return;} 1234567//date:10-27//第二题int countNode(NOde* p){ if(p==NULL) return 0; return 1+countNode(p-&gt;lchild)+countNode(p-&gt;rchild);} 2012 1234567891011121314151617181920212223242526272829303132333435363738//date:10-27//假设最大值只有一个void DeleteMaxNode(LinkList &amp;L){ if(L-&gt;next==NULL) return; lnode*p=L; //用来遍历 lnode*t=L; //用来记录值最大的结点的前驱结点 while(p-&gt;next!=NULL){ if(p-&gt;next-&gt;data&gt;t-&gt;next-&gt;data) t=p; p=p-&gt;next; } t-&gt;next=t-&gt;next-&gt;next; }//假设最大值有很多个void DeleteMaxNode(LinkList &amp;L){ //假设链表为空，直接返回 if(L-&gt;next==NULL) return; lnode*p=L-&gt;next; Elemtype Max=p-&gt;data; //第一轮，找出最大值 while(p!=NULL){ if(p-&gt;data&gt;Max) Max=p-&gt;data; p=p-&gt;next; } lnode*t=L; //第二轮，删除所有data等于max的结点 while(t-&gt;next!=NULL){ if(t-&gt;next-&gt;data!=Max) t=t-&gt;next; else{ t-&gt;next=t-&gt;next-&gt;next; } }} 1234567891011//date：10-27int count(BTreeNode*BT,Elemtype X){ if(BT==NULL) return 0; int l=count(BT-&gt;left,X); int r=count(BT-&gt;right,X); if(BT-&gt;data&lt;X) return 1+l+r; else return l+r;} 2009*快速排序 12345678910111213141516171819202122232425//date:11-2//第一题int partition(int arr[],int low,int high){ //一次划分 int pivot=arr[low]; //high右边都是&gt;=pivot的元素 //low左边都是&lt;pivot的元素 while(low&lt;high){ while(low&lt;high &amp;&amp; arr[high]&gt;=pivot) //找到第一个小于pivot的元素 high--; arr[low]=arr[high]; while(low&lt;high &amp;&amp; arr[low]&lt;pivot) //找到第一个大于等于pivot的元素 low++; arr[high]=arr[low]; } arr[low]=pivot; return low;}void quickSort2(int arr[],int low,int high){ if(low&lt;high){ int t=partition(arr,low,high); //t用来记录基准元素的位置 quickSort2(arr,low,t-1); //注意递归调用函数不要调错了 quickSort2(arr,t+1,high); }} 123456789101112131415161718192021222324252627282930313233343536373839//date:10-28lnode* merge(lnode* la,lnode* lb){ lnode*lc=(lnode*)malloc(sizeof(lnode)); lc-&gt;next=NULL; lnode*p1=la-&gt;next,*p2=lb-&gt;next,*p3=lc; while(p1!=NULL &amp;&amp; p2!=NULL){ lnode*t=(lnode*)malloc(sizeof(lnode)); t-&gt;next=NULL; if(p1-&gt;data&lt;=p2-&gt;data){ t-&gt;data=p1-&gt;data; p3-&gt;next=t; p1=p1-&gt;next; } else{ t-&gt;data=p2-&gt;data; p3-&gt;next=t; p2=p2-&gt;next; } p3=p3-&gt;next; } while(p1!=NULL){ lnode*t=(lnode*)malloc(sizeof(lnode)); t-&gt;data=p1-&gt;data; t-&gt;next=NULL; p3-&gt;next=t; p3=p3-&gt;next; } while(p2!=NULL){ lnode*t=(lnode*)malloc(sizeof(lnode)); t-&gt;data=p2-&gt;data; t-&gt;next=NULL; p3-&gt;next=t; p3=p3-&gt;next; } return lc;} 2007 12345678910111213141516171819202122//date:10-29//第二题struct Arc{ int key; Arc* next;};struct Vertex{ int key; //int len; Arc*firstNode;};void DelArc(Vertex adj[],int u,int v){ Arc*p=adj[u-1].firstArc; if(p-&gt;key==v){ adj[u-1].firstArc=p-&gt;next; return; } while(p-&gt;next-&gt;key!=v) p=p-&gt;next; p-&gt;next=p-&gt;next-&gt;next; return;} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//date:10-28//第一题//非递归void insert(Node* &amp;tree,int x){ Node*p=tree; Node*t=(Node*)malloc(sizeof(Node)); t-&gt;data=x; t-&gt;lchild=NULL; t-&gt;rchild=NULL; if(tree==NULL){ tree=t; return; } while(p!=NULL){ if(p-&gt;data&lt;x &amp;&amp; p-&gt;rchild!=NULL) p=p-&gt;rchild; else if(p-&gt;data&gt;x &amp;&amp; p-&gt;lchild!=NULL) p=p-&gt;lchild; else if(p-&gt;data&lt;x &amp;&amp; p-&gt;rchild==NULL){ //插入 p-&gt;rchild=t; return; } else{ //插入 p-&gt;lchild=t; return; } } }//非递归方法二：void insert(Node* &amp;tree,int x){ Node*p=tree; Node*pre=NULL; Node*t=(Node*)malloc(sizeof(Node)); t-&gt;data=x; t-&gt;lchild=NULL; t-&gt;rchild=NULL; if(tree==NULL){ tree=t; return; } while(p!=NULL){ pre=p; if(p-&gt;data&lt;x) p=p-&gt;rchild; else p=p-&gt;lchild; } if(pre-&gt;data&lt;x) pre-&gt;rchild=t; else pre-&gt;lchild=t; return;}//递归void insert(Node* &amp;tree,int x){ if(tree==NULL){ tree=(Node*)malloc(sizeof(Node)); tree-&gt;data=x; tree-&gt;lchild=NULL; tree-&gt;rchild=NULL; return; } /* if(tree-&gt;data&lt;x &amp;&amp; tree-&gt;rchild==NULL){ tree-&gt;rchild=(Node*)malloc(sizeof(Node)); Node*t=tree-&gt;rchild t-&gt;data=x; t-&gt;lchild=NULL; t-&gt;rchild=NULL; return; } if(tree-&gt;data&gt;x &amp;&amp; tree-&gt;lchild==NULL){ tree-&gt;lchild=(Node*)malloc(sizeof(Node)); Node*t=tree-&gt;lchild t-&gt;data=x; t-&gt;lchild=NULL; t-&gt;rchild=NULL; return; }*/ if(tree-&gt;data&lt;x) insert(tree-&gt;rchild,x); else insert(tree-&gt;lchild,x); } 123456789101112131415161718//date:10-29//第一题//把s复制到d上void treecopy(Node* &amp;d,Node* s){ if(s==NULL) { d=NULL; return; } /*if(s-&gt;lchild==NULL &amp;&amp; s-&gt;rchild==NULL){ d=(Node*)malloc(sizeof(Node)); d-&gt;data=s-&gt;data; return; }*/ d=(Node*)malloc(sizeof(Node)); d-&gt;data=s-&gt;data; return treecopy(d-&gt;lchild,s-&gt;lchild) &amp;&amp; treecopy(d-&gt;rchild,s-&gt;rchild); } 1234567891011121314151617//date:10-29//第二题void Convert(int r[],Node* la,int n){ if(n==0) return; Node*t=la; for(int i=0;i&lt;n;i++){ Node*p=(Node*)malloc(sizeof(Node)); p-&gt;data=r[i]; p-&gt;next=NULL; p-&gt;prior=t; t-&gt;next=p; t=t-&gt;next; } return;} 注意递归过程123456789101112//date:10-30//递归void Convert(int r[],Node* la,int n){ if(n==0) return; la-&gt;next=(Node*)malloc(sizeof(Node)); la-&gt;next-&gt;prior=la; la-&gt;next-&gt;data=r[0]; Convert(r+1,la-&gt;next,n-1); } 2006 123456789101112//date:10-29//第一题int treeleaf(Node* p){ if(p==NULL) return 0; //下面这个终止条件忘了写了 if(p-&gt;lchild==NULL &amp;&amp; p-&gt;rchild==NULL) return 1; int l=treeleaf(p-&gt;lchild); int r=treeleaf(p-&gt;rchild); return l+r;} 123456789101112131415161718192021//date:10-29//第二题int outdegree[N];void finddegree(Vertex adj[],int n){ for(int i=0;i&lt;n;i++){ int count=0; Arc*p=adj[i].firstArc; if(p==NULL) outdegree[i]=0; else{ while(p!=NULL){ count++; p=p-&gt;next; } adj[i]=count; } } } 12345678910111213//date:10-29//第一题void exchange(Node* root){ if(root==NULL) return; Node*tmp=root-&gt;lchild; root-&gt;lchild=root-&gt;rchild; root-&gt;rchild=tmp; exchange(root-&gt;lchild); exchange(root-&gt;rchild); } 注意两个if的条件12345678910111213141516171819202122//date:10-29//第二题void delMinMax(DLnode* head,int min,int max){ DLnode*p=head; while(p-&gt;next!=NULL &amp;&amp; p-&gt;next-&gt;data&lt;=min) //要&lt;=min,不能是&lt;min p=p-&gt;next; if(p-&gt;next==NULL) return; DLnode*p1=p; while(p-&gt;next-&gt;data&lt;max &amp;&amp; p-&gt;next!=NULL) //只能是&lt;max,不能&lt;=max p=p-&gt;next; //下面写麻烦了，可以删去 /*if(p-&gt;next==NULL){ p1-&gt;next=NULL; return; }*/ p1-&gt;next=p-&gt;next; p1-&gt;next-&gt;pre=p1; } 12345678910111213//date:10-30//第二题，递归void delMinMax(DLnode* head,int min,int max){ if(head-&gt;next=NULL) return; if(head-&gt;next-&gt;data&gt;min &amp;&amp; head-&gt;next-&gt;data&lt;max){ head-&gt;next=head-&gt;next-&gt;next; head-&gt;next-&gt;next-&gt;pre=head-&gt;next; } deMinMax(head-&gt;next,min,max); } 2003 12345678910111213141516171819202122232425//date:10-27//非递归int countEven(Node* H){ Node*p=H; int count=0; if(p==NULL) return 0; while(p!=NULL){ if(p-&gt;data%2==0) count++; p=p-&gt;next; } return count;}//递归int countEven(Node* H){ if(H==NULL) return 0; if(H-&gt;data%2==0) return 1+countEven(H-&gt;next); else return countEven(H-&gt;next);} 常考题型总结 链表 单链表 循环链表 顺序表 二叉树 递归 非递归方法 图 dfs bfs 邻接表 邻接矩阵 任务完成leetcode中所有关于链表、图、二叉树、顺序表的简单题，每天至少一题，链接地址如下 链表简单题合集 二叉树简单题合集 图的简单题合集 递归简单题合集 数组简单题合集，题目较多，小余挑一些给你写 往年真题补充一 二 三 四 五 六 七","link":"/2022/04/27/%E7%AE%97%E6%B3%95/%E5%8D%97%E7%90%86%E5%B7%A5877%E5%8E%86%E5%B9%B4%E5%88%9D%E8%AF%95%E7%9C%9F%E9%A2%98/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"二分搜索","slug":"二分搜索","link":"/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"},{"name":"单调栈","slug":"单调栈","link":"/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"前缀和与差分","slug":"前缀和与差分","link":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"},{"name":"快慢指针","slug":"快慢指针","link":"/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"},{"name":"滑动窗口","slug":"滑动窗口","link":"/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"}]}