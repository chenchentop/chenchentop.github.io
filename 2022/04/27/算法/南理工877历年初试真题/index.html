<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>南理工877历年初试真题 - Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="个人整理历年真题答案"><meta property="og:type" content="blog"><meta property="og:title" content="南理工877历年初试真题"><meta property="og:url" content="http://example.com/2022/04/27/%E7%AE%97%E6%B3%95/%E5%8D%97%E7%90%86%E5%B7%A5877%E5%8E%86%E5%B9%B4%E5%88%9D%E8%AF%95%E7%9C%9F%E9%A2%98/"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="个人整理历年真题答案"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/%E5%8E%86%E5%B9%B4%E7%9C%9F%E9%A2%98%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86(3).assets/image-20211009174013098.png"><meta property="og:image" content="http://example.com/%E5%8E%86%E5%B9%B4%E7%9C%9F%E9%A2%98%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86(3).assets/image-20211009174045842.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919142038319.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919142051360.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919142102446.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919131407233.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919131424320.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919131501358.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919131534334.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132122394.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132152938.png"><meta property="og:image" content="http://example.com/2022/04/27/%E7%AE%97%E6%B3%95/%E5%8D%97%E7%90%86%E5%B7%A5877%E5%8E%86%E5%B9%B4%E5%88%9D%E8%AF%95%E7%9C%9F%E9%A2%98/历年真题算法题整理(3).assets/image-20211020225422525.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132217111.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132232059.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132252975.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132310985.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132338490.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132405006.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132443745.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132501471.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132523831.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132535659.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132550472.png"><meta property="og:image" content="http://example.com/%E5%8E%86%E5%B9%B4%E7%9C%9F%E9%A2%98%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86(3).assets/image-20211106155656300.png"><meta property="og:image" content="http://example.com/%E5%8E%86%E5%B9%B4%E7%9C%9F%E9%A2%98%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86(3).assets/image-20211106155714089.png"><meta property="og:image" content="http://example.com/%E5%8E%86%E5%B9%B4%E7%9C%9F%E9%A2%98%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86(3).assets/image-20211106155727852.png"><meta property="og:image" content="http://example.com/%E5%8E%86%E5%B9%B4%E7%9C%9F%E9%A2%98%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86(3).assets/image-20211106155748548.png"><meta property="og:image" content="http://example.com/%E5%8E%86%E5%B9%B4%E7%9C%9F%E9%A2%98%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86(3).assets/image-20211106155802023.png"><meta property="og:image" content="http://example.com/%E5%8E%86%E5%B9%B4%E7%9C%9F%E9%A2%98%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86(3).assets/image-20211106155816682.png"><meta property="og:image" content="http://example.com/%E5%8E%86%E5%B9%B4%E7%9C%9F%E9%A2%98%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86(3).assets/image-20211106155826168.png"><meta property="article:published_time" content="2022-04-27T09:07:19.638Z"><meta property="article:modified_time" content="2022-04-27T09:09:41.400Z"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/%E5%8E%86%E5%B9%B4%E7%9C%9F%E9%A2%98%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86(3).assets/image-20211009174013098.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2022/04/27/%E7%AE%97%E6%B3%95/%E5%8D%97%E7%90%86%E5%B7%A5877%E5%8E%86%E5%B9%B4%E5%88%9D%E8%AF%95%E7%9C%9F%E9%A2%98/"},"headline":"南理工877历年初试真题","image":["http://example.com/%E5%8E%86%E5%B9%B4%E7%9C%9F%E9%A2%98%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86(3).assets/image-20211009174013098.png","http://example.com/%E5%8E%86%E5%B9%B4%E7%9C%9F%E9%A2%98%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86(3).assets/image-20211009174045842.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919142038319.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919142051360.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919142102446.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919131407233.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919131424320.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919131501358.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919131534334.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132122394.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132152938.png","http://example.com/2022/04/27/%E7%AE%97%E6%B3%95/%E5%8D%97%E7%90%86%E5%B7%A5877%E5%8E%86%E5%B9%B4%E5%88%9D%E8%AF%95%E7%9C%9F%E9%A2%98/历年真题算法题整理(3).assets/image-20211020225422525.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132217111.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132232059.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132252975.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132310985.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132338490.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132405006.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132443745.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132501471.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132523831.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132535659.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132550472.png","http://example.com/%E5%8E%86%E5%B9%B4%E7%9C%9F%E9%A2%98%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86(3).assets/image-20211106155656300.png","http://example.com/%E5%8E%86%E5%B9%B4%E7%9C%9F%E9%A2%98%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86(3).assets/image-20211106155714089.png","http://example.com/%E5%8E%86%E5%B9%B4%E7%9C%9F%E9%A2%98%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86(3).assets/image-20211106155727852.png","http://example.com/%E5%8E%86%E5%B9%B4%E7%9C%9F%E9%A2%98%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86(3).assets/image-20211106155748548.png","http://example.com/%E5%8E%86%E5%B9%B4%E7%9C%9F%E9%A2%98%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86(3).assets/image-20211106155802023.png","http://example.com/%E5%8E%86%E5%B9%B4%E7%9C%9F%E9%A2%98%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86(3).assets/image-20211106155816682.png","http://example.com/%E5%8E%86%E5%B9%B4%E7%9C%9F%E9%A2%98%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86(3).assets/image-20211106155826168.png"],"datePublished":"2022-04-27T09:07:19.638Z","dateModified":"2022-04-27T09:09:41.400Z","author":{"@type":"Person","name":"John Doe"},"publisher":{"@type":"Organization","name":"Hexo","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":"个人整理历年真题答案"}</script><link rel="canonical" href="http://example.com/2022/04/27/%E7%AE%97%E6%B3%95/%E5%8D%97%E7%90%86%E5%B7%A5877%E5%8E%86%E5%B9%B4%E5%88%9D%E8%AF%95%E7%9C%9F%E9%A2%98/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-27T09:07:19.638Z" title="2022/4/27 17:07:19">2022-04-27</time>发表</span><span class="level-item"><time dateTime="2022-04-27T09:09:41.400Z" title="2022/4/27 17:09:41">2022-04-27</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span><span class="level-item">1 小时读完 (大约7212个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">南理工877历年初试真题</h1><div class="content"><h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h1 id="真题编程题"><a href="#真题编程题" class="headerlink" title="真题编程题"></a>真题编程题</h1><h2 id="第一题2013年：求二叉树高度"><a href="#第一题2013年：求二叉树高度" class="headerlink" title="第一题2013年：求二叉树高度"></a>第一题2013年：求二叉树高度</h2><p><strong>题目</strong></p>
<p>编写算法求二叉树T的高度,数据结构用二叉链表表示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span><span class="number">-9</span></span><br><span class="line"><span class="comment">//非递归算法</span></span><br><span class="line"><span class="comment">//利用层序遍历</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt;que;		</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt;temp;</span><br><span class="line">        <span class="type">int</span> h=<span class="number">0</span>;</span><br><span class="line">        que.push(root);         <span class="comment">//根节点入队                 </span></span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">     <span class="comment">//队列不空的时候，让左右孩子进临时队列（如果存在），队头元素出队</span></span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            TreeNode* t=que.front();</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">                temp.push(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">                temp.push(t-&gt;right);</span><br><span class="line">            que.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//把临时队列里的元素再复制回去</span></span><br><span class="line">        <span class="keyword">while</span>(!temp.empty())&#123;</span><br><span class="line">            TreeNode*p=temp.front();</span><br><span class="line">            que.push(p);</span><br><span class="line">            temp.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        h++;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> <span class="comment">//递归算法</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">Btdepth</span><span class="params">(TreeNode *T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l=Btdepth(T-&gt;lchild);</span><br><span class="line">    <span class="type">int</span> r=Btdepth(T-&gt;rchild);</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)</span><br><span class="line">        <span class="keyword">return</span> l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> r+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>leetcode类似题目</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">剑指offer55</a></p>
<p><strong>考察知识点</strong></p>
<p>二叉树、递归</p>
<h2 id="第二题2014年"><a href="#第二题2014年" class="headerlink" title="第二题2014年"></a>第二题2014年</h2><p><strong>题目</strong></p>
<p>二叉树采用二叉链表作为存储结构，链表中结点的结构为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    <span class="title">BitNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    biteNode*lchid,*rchild;</span><br><span class="line">&#125;bitNode;</span><br></pre></td></tr></table></figure>

<p>构造一个递归算法计算二叉树中值等于x的结点的个数。函数原型为countx(bitNode *t, int x)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countx</span><span class="params">(bitNode*t,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l=<span class="built_in">countx</span>(t-&gt;lchild);</span><br><span class="line">    <span class="type">int</span> r=<span class="built_in">count</span>(t-&gt;rchild);</span><br><span class="line">    <span class="keyword">if</span>(t-&gt;data==x)</span><br><span class="line">        <span class="keyword">return</span> l+r+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">   		<span class="keyword">return</span> l+r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归算法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">遍历</span><br></pre></td></tr></table></figure>



<h2 id="第三题2015-1"><a href="#第三题2015-1" class="headerlink" title="第三题2015-1"></a>第三题2015-1</h2><p><strong>题目</strong></p>
<p>设计计算二叉树中所有节点值之和的算法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l=<span class="built_in">sum</span>(root-&gt;lchild);</span><br><span class="line">    <span class="type">int</span> r=<span class="built_in">sum</span>(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> root-&gt;data+l+r;</span><br><span class="line">&#125;            </span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(NOde* root)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    Node*p=root;</span><br><span class="line">    stack&lt;Node*&gt;st;</span><br><span class="line">    <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() || p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            st.<span class="built_in">push</span>(p);</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">            ans=ans+st.<span class="built_in">top</span>()-&gt;data;</span><br><span class="line">        &#125;</span><br><span class="line">        p=st.<span class="built_in">top</span>()-&gt;rchild;</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第四题2015-2：顺序表中奇数挪到偶数前"><a href="#第四题2015-2：顺序表中奇数挪到偶数前" class="headerlink" title="第四题2015-2：顺序表中奇数挪到偶数前"></a>第四题2015-2：顺序表中奇数挪到偶数前</h2><p><strong>题目</strong></p>
<p>设计将一个顺序存储的线性数表中所有奇数移动到所有偶数之前的算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SeqList</span>&#123;</span></span><br><span class="line">  	<span class="type">int</span>* L;</span><br><span class="line">  	<span class="type">int</span> len,maxLen;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(SeqList L,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=L.data[i];</span><br><span class="line">    L.data[i]=L.data[j];</span><br><span class="line">    L.data[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">(SeqList L)</span>&#123;</span><br><span class="line">   	<span class="type">int</span> i=<span class="number">0</span>,j=len<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp; L.data[i]%<span class="number">2</span>==<span class="number">1</span>)		<span class="comment">//从前往后找到第一个偶数</span></span><br><span class="line">        	i++;</span><br><span class="line">    	<span class="keyword">while</span>(i&lt;j &amp;&amp; L.data[j]%<span class="number">2</span>==<span class="number">0</span>)		<span class="comment">//从后往前找到第一个奇数</span></span><br><span class="line">        	j--;</span><br><span class="line">        <span class="comment">//错了</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)								<span class="comment">//防止全部都是奇数或者全是偶数，导致指针越界</span></span><br><span class="line">            swap(L,i,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>













<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SeqList</span>&#123;</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line">    <span class="type">int</span> len,maxlen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(SeqList L,<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=L.data[i];</span><br><span class="line">    L.data[i]=L.data[j];</span><br><span class="line">    L.data[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(SeqList L)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=L.len<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;						<span class="comment">//循环</span></span><br><span class="line">       <span class="keyword">while</span>(i&lt;j &amp;&amp; L.data[i]%<span class="number">2</span>==<span class="number">1</span>)	<span class="comment">//从左往右，找到第一个偶数的时候，停下来</span></span><br><span class="line">        	i++;</span><br><span class="line">       <span class="keyword">while</span>(i&lt;j &amp;&amp; L.data[j]%<span class="number">2</span>==<span class="number">0</span>)	<span class="comment">//从右往左，找到第一个奇数的时候，停下来</span></span><br><span class="line">        	j--;</span><br><span class="line">       <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">        	<span class="built_in">swap</span>(L,i,j);  </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>小余的代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=arr[l];</span><br><span class="line">    arr[l]=arr[r];</span><br><span class="line">    arr[r]=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将数组中的奇数放前边，偶数放后边*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveOddAndEven</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r &amp;&amp; arr[l]%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">            l++;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r &amp;&amp; arr[r]%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            r--;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;r)</span><br><span class="line">            <span class="built_in">swap</span>(arr,l,r);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第五题2015-3"><a href="#第五题2015-3" class="headerlink" title="第五题2015-3"></a>第五题2015-3</h2><p><strong>题目</strong></p>
<p>设计算法判断单链表中元素是否递增</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不带头结点的</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(Node* L)</span>&#123;</span><br><span class="line">    Node*p=L;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data&gt;p-&gt;next-&gt;data)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(Node* L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span> || L-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;data&gt;L-&gt;next-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> check(L-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><strong>小余的代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*判断单链表元素是否递增*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(Node*head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(head-&gt;next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next-&gt;data&lt;head-&gt;data)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断单链表元素是否递增,递归写法*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check2</span><span class="params">(Node*head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">check2</span>(head-&gt;next) &amp;&amp; head-&gt;next-&gt;data&gt;=head-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第六题2017：删除单循环链表中重复结点值"><a href="#第六题2017：删除单循环链表中重复结点值" class="headerlink" title="第六题2017：删除单循环链表中重复结点值"></a>第六题2017：删除单循环链表中重复结点值</h2><p><strong>题目</strong></p>
<p>已知一个带头节点的单循环链表的数据结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lnode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    lnode*next;</span><br><span class="line">&#125;lnode;</span><br></pre></td></tr></table></figure>

<p>假设链表中可能存在多个值相同的结点，请设计一个算法，删除链表中值重复的其他节点（注意保留第一个值得节点），使得链表中无值相同的结点。函数原型为void deletex(lnode * &amp;head)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">deletex</span><span class="params">(lnode* &amp;head)</span>&#123;</span><br><span class="line">    lnode*p=head-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(p!=head)&#123;</span><br><span class="line">        lnode*pre=p;</span><br><span class="line">        lnode* t=p-&gt;next;</span><br><span class="line">        <span class="type">int</span> key=p-&gt;data;</span><br><span class="line">        <span class="comment">//t往后走一圈，检查有没有跟key重复的</span></span><br><span class="line">        <span class="keyword">while</span>(t!=head)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;data==key)&#123;</span><br><span class="line">                <span class="comment">//重复了，删掉该结点</span></span><br><span class="line">              	pre-&gt;next=t-&gt;next;</span><br><span class="line">                t=t-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//不重复，继续往后走</span></span><br><span class="line">                pre=t;</span><br><span class="line">                t=t-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p=p-&gt;next;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*单循环链表（带头节点）中，删除链表中值重复的其他节点（注意保留第一个值得节点），使得链表中无值相同的结点*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deletex</span><span class="params">(Node* &amp;head)</span></span>&#123;</span><br><span class="line">    Node*start=head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(start!=head)&#123;</span><br><span class="line">        <span class="comment">//把所有和start值相同的节点删除</span></span><br><span class="line">        Node*t=start-&gt;next;</span><br><span class="line">        Node*pre=start;</span><br><span class="line">        <span class="keyword">while</span>(t!=head)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;data==start-&gt;data)&#123;</span><br><span class="line">                pre-&gt;next=t-&gt;next;</span><br><span class="line">                t=t-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre=pre-&gt;next;</span><br><span class="line">                t=pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        start=start-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第七题2018：判断图两个顶点是否连通"><a href="#第七题2018：判断图两个顶点是否连通" class="headerlink" title="第七题2018：判断图两个顶点是否连通"></a>第七题2018：判断图两个顶点是否连通</h2><p><strong>题目</strong></p>
<p>假设一个不带权的无向图采用邻接表G进行存储，设计一个算法FindaPath(G, u, v, &amp;has)，判断该图中顶点u到顶点v是否连通，如果连通，has为1，否则为0，在调用该算法之前has置初值为0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date:10-22</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Arc</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="comment">//int len;		//权值</span></span><br><span class="line">    Arc* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span>&#123;</span></span><br><span class="line">  	<span class="type">int</span> key;</span><br><span class="line">    Arc* firstArc;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//图</span></span><br><span class="line"><span class="comment">//Vertx* adj[MaxSize];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span>&#123;</span></span><br><span class="line">  	<span class="type">int</span> e;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vertex adj[MaxSize];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FindaPath</span><span class="params">(Graph G,<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> &amp;has)</span>&#123;</span><br><span class="line">    Arc*p=adj[u].firstArc;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;key==v)&#123;</span><br><span class="line">            has=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    has=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1000</span></span><br><span class="line">using namesapce <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//边表的结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Arc</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> key;		<span class="comment">//几号顶点</span></span><br><span class="line">    Arc* next;</span><br><span class="line">    <span class="comment">//int info;		//权值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//顶点表中的顶点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> key;	<span class="comment">//顶点号</span></span><br><span class="line">    Arc* firstArc;		<span class="comment">//指向边表的第一个结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//邻接表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> n;			<span class="comment">//n个结点</span></span><br><span class="line">    <span class="type">int</span> e;			<span class="comment">//e条边</span></span><br><span class="line">    Vertext adj[MAX];		<span class="comment">//顶点表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FindaPath</span><span class="params">(Graph G, <span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> &amp;has)</span> &#123;</span><br><span class="line">    Arc* p=G.adj[u].firstArc;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;key==v)&#123;</span><br><span class="line">            has=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    has=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>小余的代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//图的邻接表的定义：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*边表的节点*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ArcNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> vertex;    <span class="comment">//几号顶点, 或者变量名写成adjvex，即adjacent vertex 相邻的顶点</span></span><br><span class="line">    ArcNode *next;</span><br><span class="line">    <span class="comment">//int info;   //带权的可以记录权值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*数组顶点表中的顶点*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;   <span class="comment">//该顶点存储的数据</span></span><br><span class="line">    ArcNode *firstArc; <span class="comment">//</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*邻接表*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="type">int</span> N;  <span class="comment">//一共有N个节点</span></span><br><span class="line">    <span class="type">int</span> e;  <span class="comment">//一共e条边</span></span><br><span class="line">    VNode AdjList[MAX]; <span class="comment">//顶点表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findPath</span><span class="params">(Graph G,<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">bool</span> &amp;has )</span></span>&#123;</span><br><span class="line">    ArcNode*p=G.AdjList[u].firstArc;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;vertex==v)</span><br><span class="line">        &#123;</span><br><span class="line">            has=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>答案</strong></p>
<p><img src="/%E5%8E%86%E5%B9%B4%E7%9C%9F%E9%A2%98%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86(3).assets/image-20211009174013098.png" alt="image-20211009174013098"></p>
<p><img src="/%E5%8E%86%E5%B9%B4%E7%9C%9F%E9%A2%98%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86(3).assets/image-20211009174045842.png" alt="image-20211009174045842"></p>
<p><strong>南理工ppt对邻接表的定义</strong></p>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919142038319.png" alt="image-20210919142038319"></p>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919142051360.png" alt="image-20210919142051360"></p>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919142102446.png" alt="image-20210919142102446"></p>
<h2 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h2><p><strong>题目</strong></p>
<p>非递归查找叶子结点（题目不完整，查找个数？）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findleaf</span><span class="params">(Node* root)</span>&#123;</span><br><span class="line">    <span class="comment">//第一种情况，指针为空</span></span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//root是叶子结点</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;lchild==<span class="literal">NULL</span> &amp;&amp; root-&gt;rchild==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//root不是叶子结点</span></span><br><span class="line">    <span class="type">int</span> l=findleaf(root-&gt;lchild);</span><br><span class="line">    <span class="type">int</span> r=findleaf(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> l+r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归，层序遍历</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findleaf1</span><span class="params">(Node*root)</span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node*&gt;que;</span><br><span class="line">    Node*p=root;</span><br><span class="line">    que.push(p);</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty()&#123;</span><br><span class="line">        Node*first=que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">if</span>(first-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line">            que.push(first-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(first-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">            que.push(first-&gt;rchild);</span><br><span class="line">        <span class="keyword">if</span>(first-&gt;lchild==<span class="literal">NULL</span> &amp;&amp; first-&gt;rchild==<span class="literal">NULL</span>)</span><br><span class="line">            count++;  </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//data:10-18   </span></span><br><span class="line"><span class="type">int</span> findleaf(Node* root)&#123;</span><br><span class="line">    <span class="comment">//第一种情况，指针为空</span></span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)		<span class="comment">//第一种情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;lchild!=<span class="literal">NULL</span> &amp;&amp; root-&gt;rchild==<span class="literal">NULL</span>)		<span class="comment">//第二种情况</span></span><br><span class="line">        <span class="keyword">return</span> findleaf(root-&gt;lchild);</span><br><span class="line">     <span class="keyword">if</span>(root-&gt;lchild!=<span class="literal">NULL</span> &amp;&amp; root-&gt;rchild!=<span class="literal">NULL</span>)		<span class="comment">//第三种情况</span></span><br><span class="line">        <span class="keyword">return</span> findleaf(root-&gt;rchild);</span><br><span class="line">    <span class="comment">//root是叶子结点</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;lchild==<span class="literal">NULL</span> &amp;&amp; root-&gt;rchild==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//root不是叶子结点</span></span><br><span class="line">    <span class="keyword">return</span> findleaf(root-&gt;lchild)+findleaf(root-&gt;rchild);<span class="comment">//第四种情况，第四种情况包含第二三种情况，所以第二三种情况可以删去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>思路</strong></p>
<p>非递归，则考虑<strong>前中后序遍历</strong>和<strong>层序遍历</strong>。</p>
<h2 id="第九题2019-2：合并两个递增链表，不允许元素重复"><a href="#第九题2019-2：合并两个递增链表，不允许元素重复" class="headerlink" title="第九题2019-2：合并两个递增链表，不允许元素重复"></a>第九题2019-2：合并两个递增链表，不允许元素重复</h2><p><strong>题目</strong></p>
<p>合并两个递增链表a和b，最后存在a中，不允许同样的元素存在</p>
<p><strong>类似题目</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">leetcode 21</a></p>
<p><strong>小余的代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*合并ab两个递增链表，最后存在a中，不允许同样的元素存在*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(Node* &amp;a, Node* &amp;b)</span> </span>&#123;</span><br><span class="line">    Node *t=(Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));    <span class="comment">//创建一个带头节点的临时链表</span></span><br><span class="line">    t-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    Node*p1=a,*p2=b,*p3=t;</span><br><span class="line">    <span class="keyword">while</span>(p1!=<span class="literal">NULL</span> &amp;&amp; p2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="type">int</span> newData;		<span class="comment">//用来接收p1和p2中较小的数值		</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;data&lt;p2-&gt;data)&#123;     <span class="comment">//如果p1小，p1的值给newdata，如何p1往后走</span></span><br><span class="line">            newData=p1-&gt;data;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p1-&gt;data&gt;p2-&gt;data)&#123;		<span class="comment">//如果p2小，p2的值给newdata，如何p2往后走</span></span><br><span class="line">            newData=p2-&gt;data;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            newData=p1-&gt;data;			<span class="comment">//如果p1和p2一样大，p1和p2任意的值给newdata，p1和p2都往后走</span></span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//临时链表增加一个节点					//每次把newdata插入到临时链表的末尾</span></span><br><span class="line">        p3-&gt;next=(Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">        p3=p3-&gt;next;</span><br><span class="line">        p3-&gt;data=newData;</span><br><span class="line">        p3-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(p1!=<span class="literal">NULL</span>)&#123;			<span class="comment">//若p2已经空了，用p1和p3比较。若p1有重复元素，就会导致p1和p3参与比较的结点值相等，就直接让p1后移</span></span><br><span class="line">        <span class="comment">//挪到不相等的时候，p1的值只可能会比p3大，将P1的值插入p3</span></span><br><span class="line">        <span class="keyword">if</span>(p3-&gt;data&lt;p1-&gt;data)&#123;			<span class="comment">//p3的值不可能比p1的值大</span></span><br><span class="line">            p3-&gt;next=(Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">            p3-&gt;next-&gt;data=p1-&gt;data;</span><br><span class="line">            p3=p3-&gt;next;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        p1=p1-&gt;next;           </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">         <span class="keyword">if</span>(p3-&gt;data&lt;p2-&gt;data)&#123;</span><br><span class="line">            p3-&gt;next=(Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">            p3-&gt;next-&gt;data=p2-&gt;data;</span><br><span class="line">            p3=p3-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p2=p2-&gt;next;  </span><br><span class="line">    &#125;</span><br><span class="line">    p3-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    a=t-&gt;next;  <span class="comment">//将结果存在a链中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上次写的日期：</span></span><br></pre></td></tr></table></figure>

<h2 id="第十题2019-1"><a href="#第十题2019-1" class="headerlink" title="第十题2019-1*"></a>第十题2019-1*</h2><p><strong>题目</strong></p>
<p>合并两个递增有序的链表为一个新的链表，删除重复元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 第十一题<span class="number">2020</span><span class="number">-2</span>*</span><br><span class="line"></span><br><span class="line">**题目**</span><br><span class="line"></span><br><span class="line">非递归判断一棵树是否为排序二叉树，求时间复杂度</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="comment">//书写日期：10-8</span></span><br><span class="line"><span class="comment">//二叉排序树的中序遍历序列是递增的</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(TreeNode* root)</span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt;st;</span><br><span class="line">    TreeNode*p=root;</span><br><span class="line">    <span class="comment">//vector&lt;int&gt;ans; </span></span><br><span class="line">	<span class="type">int</span> min=<span class="number">-99999</span>;	<span class="comment">//不可能达到的最小值,int 4字节 32位  111111111...11</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> || !st.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            st.push(p);</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//ans.push_back(st.top()-&gt;data);</span></span><br><span class="line">        <span class="keyword">if</span>(st.top()-&gt;data&lt;min)			<span class="comment">//如果栈顶元素更小，说明不是二叉排序树</span></span><br><span class="line">            <span class="keyword">return</span> fasle;</span><br><span class="line">        <span class="keyword">else</span>							<span class="comment">//如果栈顶元素比min大，说明目前为止中序遍历序列是递增的，继续往后检验</span></span><br><span class="line">            min=st.top()-&gt;data;</span><br><span class="line">        p=st.top()-&gt;rchild;</span><br><span class="line">        st.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*  	for(int j=0;j&lt;ans.size()-1;j++)&#123;</span></span><br><span class="line"><span class="comment">        if(ans[j]&gt;ans[j+1])</span></span><br><span class="line"><span class="comment">            return false;</span></span><br><span class="line"><span class="comment">    &#125;*/</span>    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<p><strong>思路</strong></p>
<p>中序遍历序列是否递增</p>
<h2 id="第十二题2020-3：判断图是否有回路"><a href="#第十二题2020-3：判断图是否有回路" class="headerlink" title="第十二题2020-3：判断图是否有回路"></a>第十二题2020-3：判断图是否有回路</h2><p><strong>题目</strong></p>
<p>图的邻接矩阵存储，写出数据结构，非递归算法（邻接表）判断无向图是否有回路。并说明邻接表和邻接矩阵的优缺点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date:10-22</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Arc</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    Arc* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    Arc* firstArc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点号从1开始</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">checkCircle</span><span class="params">(Vertex adj[n])</span>&#123;</span><br><span class="line">    <span class="type">int</span> inDegree[n];		<span class="comment">//记录各节点入度的数组，初始值全为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;				<span class="comment">//结点号从1开始</span></span><br><span class="line">        Arc*p=adj[i].firstArc;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            inDegree[p-&gt;key<span class="number">-1</span>]++;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;		<span class="comment">//记录删除结点的个数</span></span><br><span class="line">  	<span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;st;			<span class="comment">//记录入度为0的节点号</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;			<span class="comment">//数组下标从0开始</span></span><br><span class="line">        <span class="keyword">if</span>(inDegree[i]==<span class="number">0</span>)</span><br><span class="line">            st.push(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!st.empty())&#123;			<span class="comment">//逻辑删除入度为0的结点及其发出的边</span></span><br><span class="line">        <span class="type">int</span> t=st.top();</span><br><span class="line">        st.pop;</span><br><span class="line">        count++;</span><br><span class="line">        Arc*q=adj[t<span class="number">-1</span>].firstArc;</span><br><span class="line">        <span class="keyword">while</span>(q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            inDegree[q-&gt;key<span class="number">-1</span>]--;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[q-&gt;key<span class="number">-1</span>]==<span class="number">0</span>)</span><br><span class="line">                st.push(q-&gt;key);</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count&lt;n)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//日期：10-8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 30 <span class="comment">//顶点表的最大长度</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//边表结点（弧）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Arc</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    Arc* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    Arc* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span>&#123;</span></span><br><span class="line">    Vertex adj[MaxSize];</span><br><span class="line">    <span class="type">int</span> n;  <span class="comment">//顶点个数</span></span><br><span class="line">    <span class="type">int</span> e;  <span class="comment">//边的个数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图：邻接矩阵表示法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph2</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> edge[N][N];</span><br><span class="line">    <span class="type">int</span> e,n;    <span class="comment">//边和顶点的数量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断邻接表是否有环路：借鉴拓扑排序的思想</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">checkCircle</span><span class="params">(Graph G)</span>&#123;</span><br><span class="line">    <span class="comment">//记录所有顶点的入度</span></span><br><span class="line">    <span class="type">int</span> inDegree[N];	<span class="comment">//默认数组初值为0，表示未访问</span></span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* for(int i=0;i&lt;N;i++)    //初始化，考试时直接用上述注释写就可以</span></span><br><span class="line"><span class="comment">        inDegree[i]=0;*/</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        Arc*p=G.arr[i].next;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            inDegree[p-&gt;key]++;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断是否有回路</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;st;   <span class="comment">//记录入度为0（无向图则是度为1）的顶点号</span></span><br><span class="line">    <span class="comment">//遍历inDegree，初始化st</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inDegree[i]==<span class="number">0</span>)</span><br><span class="line">            st.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;    <span class="comment">//删除的顶点的个数</span></span><br><span class="line">    <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">        <span class="comment">//弹出一个栈顶元素</span></span><br><span class="line">        <span class="type">int</span> t=st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">//删除该结点以及与其指向的边（逻辑上的删除，通过减少其他结点的入度来删除的）</span></span><br><span class="line">        Arc*p=G.adj[t].next;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            inDegree[p-&gt;key]--;</span><br><span class="line">            <span class="comment">//如果入度变成0，则要入栈</span></span><br><span class="line">            <span class="keyword">if</span>(inDegree[p-&gt;key]==<span class="number">0</span>)</span><br><span class="line">                st.push(p-&gt;key);</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果循环完了，还存在顶点/边，则说明有回路</span></span><br><span class="line">    <span class="keyword">if</span>(count&lt;N)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">//表示有回路</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//data:10-18，小余的代码</span></span><br><span class="line"><span class="comment">//图的深度优先遍历，判断环(只能有向图)</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">checkCircle2</span><span class="params">(Vertex adj[],<span class="type">int</span> v0)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(visited[v0]==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;now visit &quot;</span>&lt;&lt;v0&lt;&lt;<span class="string">&quot;,conflict!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visit(v0);</span><br><span class="line">    visited[v0]=<span class="number">1</span>;</span><br><span class="line">    Arc*p=adj[v0].firstArc;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="type">bool</span> t=checkCircle2(adj,p-&gt;key);</span><br><span class="line">        <span class="keyword">if</span>(t)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">//有环，直接返回true</span></span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//v0后序路径都检查过没有环，则返回false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">邻接矩阵：优点：是可以快速判断两个顶点之间是否存在边，可以快速添加边或者删除边，方便计算结点的度；缺点：不适合存储稀疏图</span><br><span class="line">邻接表：缺点：不方便对入度结点进行操作，只能依次遍历整个邻接表；对于无向图，如果需要删除一条边，就需要在两个链表上查找并删除。优点：节省存储空间，只存储实际存在的边</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="第十三题2021-1：图的深度优先遍历"><a href="#第十三题2021-1：图的深度优先遍历" class="headerlink" title="第十三题2021-1：图的深度优先遍历"></a>第十三题2021-1：图的深度优先遍历</h2><p><strong>题目</strong></p>
<p>深度优先遍历中需要数据结构k的帮助，请问k是什么结构，有何作用及初值；写出图的深度优先遍历dfs(g, n, k, v<sub>0</sub>)  ，其中n是结点数，v<sub>0</sub>是开始节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//10-24</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 8</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//用栈实现深度优先遍历</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Arc</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    Arc *next;</span><br><span class="line"></span><br><span class="line">    Arc() : key(<span class="number">-1</span>), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Arc(<span class="type">int</span> k) : key(k), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    Arc *firstArc;</span><br><span class="line"></span><br><span class="line">    Vertex(<span class="type">int</span> k) : key(k), firstArc(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Vertex() : key(<span class="number">-1</span>), firstArc(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*无向图，有向图，均可*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(Vertex adj[], <span class="type">int</span> n, <span class="type">int</span> v0)</span> &#123;</span><br><span class="line">    <span class="type">bool</span> visited[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    visit(v0);</span><br><span class="line">    visited[v0]=<span class="literal">true</span>;</span><br><span class="line">    st.push(v0);</span><br><span class="line">    <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">        <span class="type">int</span> t = st.top();</span><br><span class="line">        Arc *p = adj[t].firstArc;</span><br><span class="line">        <span class="type">int</span> K = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[p-&gt;key]) &#123;</span><br><span class="line">                K = p-&gt;key;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果t的后继都访问过了，则弹出</span></span><br><span class="line">        <span class="keyword">if</span> (K == <span class="number">-1</span>) &#123;</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">//否则，访问未访问过的后继</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            visit(K);</span><br><span class="line">            visited[K]=<span class="literal">true</span>;</span><br><span class="line">            st.push(K); <span class="comment">//放进栈的目的是，访问其后继</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加Arc</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addArc</span><span class="params">(Vertex arr[], <span class="type">int</span> k, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[k].firstArc == <span class="literal">NULL</span>)</span><br><span class="line">        arr[k].firstArc = new Arc(s);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Arc *p = arr[k].firstArc;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        p-&gt;next = new Arc(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Vertex arr[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        arr[i].key = i;</span><br><span class="line">    &#125;</span><br><span class="line">    addArc(arr, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    addArc(arr, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    addArc(arr, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    addArc(arr, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    addArc(arr, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    addArc(arr, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    addArc(arr, <span class="number">3</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    dfs(arr, N, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//日期：10-16</span></span><br><span class="line"></span><br><span class="line">k是栈，对节点进行后进先出的访问，</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stack</span>&#123;</span></span><br><span class="line">   	<span class="type">int</span> data[MaxSize];</span><br><span class="line">    <span class="type">int</span> top=<span class="number">-1</span>;	<span class="comment">//初始值为-1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(Vertex adj[],<span class="type">int</span> n,<span class="built_in">stack</span> k,<span class="type">int</span> v0)</span>&#123;</span><br><span class="line">    <span class="type">int</span> visit[n];			<span class="comment">//标记是否访问，初值均为0</span></span><br><span class="line">    visit[v0]=<span class="number">1</span>;			<span class="comment">//表示V0已访问</span></span><br><span class="line">    k.push(v0);</span><br><span class="line">    <span class="keyword">while</span>(!k.empty())&#123;</span><br><span class="line">        <span class="comment">//找栈顶元素的一条路径</span></span><br><span class="line">        Arc*p=adj</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归进行深度优先遍历</span></span><br><span class="line"><span class="type">bool</span> visited[n];	<span class="comment">//初值为false</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(Vertex adj[],<span class="type">int</span> v0)</span>&#123;</span><br><span class="line">    visited[v0]=<span class="literal">true</span>;</span><br><span class="line">    visit(v0);	<span class="comment">//访问该结点</span></span><br><span class="line">    Arc*p=adj[v0].firstArc;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[p-&gt;key])&#123;</span><br><span class="line">            dfs(adj,p-&gt;key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(Vertex adj[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            dfs(adj,i);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>







<h2 id="第十四题2021-2：图中删除指定边"><a href="#第十四题2021-2：图中删除指定边" class="headerlink" title="第十四题2021-2：图中删除指定边"></a>第十四题2021-2：图中删除指定边</h2><p><strong>题目</strong></p>
<p>删除指定边delete(adj, u, v)</p>
<p>说明：图用<strong>邻接表</strong>存储， 数组起点为0， 顶点标号起点1， <strong>&lt;u, v&gt;存在，不用检测</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date:10-22</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Arc</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    Arc* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    Arc* firstArc;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(Vertex* adj[n],<span class="type">int</span> u,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">    Arc*p=adj[u<span class="number">-1</span>].firstArc;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;key==v)&#123;</span><br><span class="line">           adj[u<span class="number">-1</span>].firstArc=p-&gt;next;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next-&gt;key!=v)</span><br><span class="line">		   p=p-&gt;next;     </span><br><span class="line">     p-&gt;next=p-&gt;next-&gt;next;  </span><br><span class="line">     <span class="keyword">return</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//日期：10-14</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 20</span></span><br><span class="line"><span class="comment">//边表节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Arc</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="comment">//int len;</span></span><br><span class="line">    Arc* next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//顶点结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    Arc* firstArc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//图</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span>&#123;</span></span><br><span class="line">    Vertex arr[MaxSize];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(Graph &amp;adj,<span class="type">int</span> u,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">    Arc*p=adj.arr[u<span class="number">-1</span>].firstArc;			</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;key==v)</span><br><span class="line">        adj.arr[u<span class="number">-1</span>].firstArc=p-&gt;next;  <span class="comment">//注意这里不是p=p-&gt;next</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next-&gt;key!=v)</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        p-&gt;next=p-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小余写的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数：删除a指向b的边</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteArc</span><span class="params">(Graph&amp;adj,<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">	Node*p=adj.arr[a].next;	<span class="comment">//指针p，指向节点a的边表第一个节点    </span></span><br><span class="line">    <span class="comment">//如果第一个节点就是b</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;key==b)&#123;</span><br><span class="line">        adj.arr[a].next=<span class="literal">NULL</span>;		<span class="comment">//错误的哟</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next-&gt;key!=b)</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        p-&gt;next=p-&gt;next-&gt;next;	<span class="comment">//删除边</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">declar</span><span class="params">(Graph &amp;adj,<span class="type">int</span> u,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">    deleteArc(adj,u,v);</span><br><span class="line">    deleteArc(adj,v,u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第十五题2021-3：二叉树中度为1的节点数"><a href="#第十五题2021-3：二叉树中度为1的节点数" class="headerlink" title="第十五题2021-3：二叉树中度为1的节点数"></a>第十五题2021-3：二叉树中度为1的节点数</h2><p><strong>题目</strong></p>
<p>递归求二叉树中度为1的结点数 int count(p) 结点有数据域， 左孩子域，右孩子域，遍历，p为根结点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//日期 10-17/10-18</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(Node* p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)			               					<span class="comment">//p为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l=count(p-&gt;lchild);</span><br><span class="line">    <span class="type">int</span> r=count(p-&gt;rchild);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span> &amp;&amp; p-&gt;rchild==<span class="literal">NULL</span>)				<span class="comment">//p不空，但p的左孩子不空，右孩子空，递归访问左孩子</span></span><br><span class="line">        <span class="keyword">return</span> l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;lchild==<span class="literal">NULL</span> &amp;&amp; p-&gt;rchild!=<span class="literal">NULL</span>)			<span class="comment">//p不空，但p的左孩子空，右孩子不空，递归访问右孩子</span></span><br><span class="line">        <span class="keyword">return</span> r+<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">return</span> l+r;			  <span class="comment">//p的左右孩子都不空，递归访问左孩子和右孩子，加和</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//日期：10-8</span></span><br><span class="line"><span class="comment">//宝宝写的，错误，对比第8题</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(TreeNode*p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span> &amp;&amp; p-&gt;rchild==<span class="literal">NULL</span> || p-&gt;lchild==<span class="literal">NULL</span> &amp;&amp; p-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> l=count(p-&gt;lchild);</span><br><span class="line">    <span class="type">int</span> r=count(p-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> l+r;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//小余写的</span></span><br><span class="line"><span class="comment">//计算以p位根节点的树，有多少度为1的结点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(TreeNode*p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//度为1的两种情况</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;left!=<span class="literal">NULL</span> &amp;&amp; p-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> count(p-&gt;left)+<span class="number">1</span>;</span><br><span class="line">   	<span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;left==<span class="literal">NULL</span> &amp;&amp; p-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> count(p-&gt;right)+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//度为0或度为2</span></span><br><span class="line">    <span class="keyword">return</span> count(p-&gt;left)+count(p-&gt;right);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="第十六题2019"><a href="#第十六题2019" class="headerlink" title="第十六题2019"></a>第十六题2019</h2><p><strong>题目</strong></p>
<p>已知一个带有头节点的单链表，在第一个关键字为X的后面插入Y，如果没有X，则在链尾插入Y</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//日期：10-17</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node*next;</span><br><span class="line">&#125;node</span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_y</span><span class="params">(node* head,<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">    node*p=head;</span><br><span class="line">    <span class="comment">//创建节点</span></span><br><span class="line">    node*t=(node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">    t-&gt;data=y;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span>(p-&gt;next-&gt;data!=x)			<span class="comment">//寻找值为x的结点的前驱</span></span><br><span class="line">      		p=p-&gt;next;</span><br><span class="line">        <span class="keyword">else</span>&#123;						<span class="comment">//找到值为x的结点的前驱，进行插入操作</span></span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            t-&gt;next=p-&gt;next;</span><br><span class="line">            p-&gt;next=t;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;next=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//小余写的</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_y</span><span class="params">(node* head,<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">    node*p=head;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span> &amp;&amp; p-&gt;next-&gt;data!=X)</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    <span class="comment">//创建结点</span></span><br><span class="line">    node*t=(node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">    t-&gt;data=y;</span><br><span class="line">    <span class="comment">//如果走到末尾</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        t-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;next=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果走到p-&gt;next是X</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        t-&gt;next=p-&gt;next;</span><br><span class="line">        p-&gt;next=t; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="期末题编程题"><a href="#期末题编程题" class="headerlink" title="期末题编程题"></a>期末题编程题</h1><h2 id="2020年"><a href="#2020年" class="headerlink" title="2020年"></a>2020年</h2><p>1.已知一单循环链表head存放一组整型数（链表中可能有多个相同元素），构造算法删除链表中一些元素使得链表中无相同元素，并返回具有相同值元素的个数。函数原型为int DeleteNode(lnode *&amp;head)。例如：<br>初始序列：20 30 6 20 18 40 60 6 70 18<br>结束序列：20 30 6 18 40 60 70<br>返回值：3</p>
<p>   结点类型定义如下：</p>
   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lnode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    lnode*next;</span><br><span class="line">&#125;lnode;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date:10-18</span></span><br><span class="line"><span class="comment">//默认有头结点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">DeleteNode</span><span class="params">(lnode* &amp;head)</span>&#123;</span><br><span class="line">    lnode* p=head-&gt;next;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=head)&#123;</span><br><span class="line">        lnode* pre=p;		<span class="comment">//用来删除具有相同元素的结点</span></span><br><span class="line">        lnode* t=p-&gt;next;</span><br><span class="line">        <span class="type">int</span> key=p-&gt;data;</span><br><span class="line">        <span class="keyword">while</span>(t!=head)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;data==key)&#123;</span><br><span class="line">                t=t-&gt;next;</span><br><span class="line">                pre-&gt;next=t;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pre=pre-&gt;next;</span><br><span class="line">                t=t-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">              	  </span><br><span class="line">        &#125;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2.已知二叉链表数据关系定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bitnode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    bitnode*lt,*rt;</span><br><span class="line">&#125;bitnode;</span><br></pre></td></tr></table></figure>

<p>构造一个判断两个二叉树是否相似（指两棵树模式形同，结点的值可以不同）的递归算法，若相似返回1，否则返回0。函数原型为int IsAlike(bitnode*t,bitnode*s)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date:10-17，错误！！！</span></span><br><span class="line"><span class="comment">//判断分别以s和t为根节点的二叉树是否相似</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsAlisk</span><span class="params">(bitnode* t,binode* s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">NULL</span> &amp;&amp; s==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>((t-&gt;lt==<span class="literal">NULL</span> &amp;&amp;t-&gt;rt!=<span class="literal">NULL</span>) &amp;&amp; (s-&gt;lt!=<span class="literal">NULL</span>&amp;&amp; s-&gt;rt==<span class="literal">NULL</span>) || (t-&gt;lt!=<span class="literal">NULL</span> &amp;&amp; t-&gt;rt==<span class="literal">NULL</span>) &amp;&amp; (s-&gt;lt==<span class="literal">NULL</span> &amp;&amp; s-&gt;rt!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(t-&gt;lt!=<span class="literal">NULL</span> &amp;&amp; t-&gt;rt==<span class="literal">NULL</span> &amp;&amp; s-&gt;lt!=<span class="literal">NULL</span> &amp;&amp; s-&gt;rt==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> IsAlike(t-&gt;lt,s-&gt;lt);</span><br><span class="line">    <span class="keyword">if</span>(t-&gt;lt==<span class="literal">NULL</span> &amp;&amp; t-&gt;rt!=<span class="literal">NULL</span> &amp;&amp; s-&gt;lt==<span class="literal">NULL</span> &amp;&amp; s-&gt;rt!=<span class="literal">NULL</span>)</span><br><span class="line">       <span class="keyword">return</span> IsALike(t-&gt;rt,s-&gt;rt);</span><br><span class="line">    <span class="keyword">return</span> IsAlike(t-&gt;lt,s-&gt;lt) &amp;&amp; IsALike(t-&gt;rt,s-&gt;rt);   </span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line"> <span class="comment">//data:10-18</span></span><br><span class="line"><span class="type">int</span> IsAlisk(bitnode* t,binode* s)&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">NULL</span> &amp;&amp; s==<span class="literal">NULL</span>)			    <span class="comment">//s和r都空，相似</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!(t!=<span class="literal">NULL</span> &amp;&amp; s!=<span class="literal">NULL</span>))			<span class="comment">//s或t一个空一个不空，不相似</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(t!=<span class="literal">NULL</span> &amp;&amp; s!=<span class="literal">NULL</span>)&#123;				<span class="comment">//s和t都不空，递归访问其左右孩子</span></span><br><span class="line">        <span class="keyword">return</span> IsAlike(t-&gt;left,s-&gt;left) &amp;&amp; IsAlike(t-&gt;right,s-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小余的代码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isAlike</span><span class="params">(bitnode*t,bitnode*s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">NULL</span> &amp;&amp; s==<span class="literal">NULL</span>)	<span class="comment">//都为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!( t!=<span class="literal">NULL</span> &amp;&amp; s!=<span class="literal">NULL</span> ))	<span class="comment">//其中一个为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//两个都不空</span></span><br><span class="line">    <span class="keyword">if</span>( isAlike(t-&gt;left,s-&gt;left) &amp;&amp; isAlike(t-&gt;right,s-&gt;right) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h2><p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919131407233.png" alt="image-20210919131407233"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date:10-19</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归</span></span><br><span class="line">BITNode* <span class="title function_">FindMin</span><span class="params">(BITNode* t)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(t-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line">        t=t-&gt;lchild;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line">BITNode* <span class="title function_">FindMin</span><span class="params">(BITNode* t)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t-&gt;lchild==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    <span class="keyword">return</span> BITNode(t-&gt;lchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//小余写的</span></span><br><span class="line">BitNode* <span class="title function_">FindMin</span><span class="params">(BitNode*t)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(t-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">        t=t-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919131424320.png" alt="image-20210919131424320"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date:10-19</span></span><br><span class="line"><span class="comment">//值严格递增</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">intersection</span><span class="params">(lnode* &amp;ha,lnode* hb)</span>&#123;</span><br><span class="line">    lnode* temp=(lnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lnode));			<span class="comment">//创建一个临时单循环链表</span></span><br><span class="line">    temp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    lnode*a=ha-&gt;next;</span><br><span class="line">    lnode*b=hb-&gt;next;</span><br><span class="line">    lnode*c=temp;</span><br><span class="line">    <span class="keyword">while</span>(a!=ha &amp;&amp; b!=hb)&#123;			<span class="comment">//当ha和hb都没遍历完时</span></span><br><span class="line">        <span class="keyword">if</span>(a-&gt;data&lt;b-&gt;data)</span><br><span class="line">            a=a-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a-&gt;data&gt;b-&gt;data)</span><br><span class="line">            b=b-&gt;next;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            c-&gt;next=(lnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lnode));</span><br><span class="line">            c=c-&gt;next;</span><br><span class="line">            c-&gt;data=a-&gt;data;</span><br><span class="line">            c-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">            a=a-&gt;next;</span><br><span class="line">            b=b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ha-&gt;next=temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小余的代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*严格单调递增情况下*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">intersection</span><span class="params">(lnode*&amp;ha,lnode*hb)</span>&#123;	<span class="comment">//注意第一个参数加了引用</span></span><br><span class="line">    lnode*hc=(lnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lnode)); 创建新链接收相同节点</span><br><span class="line">    hc-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    lnode*p1=ha-&gt;next,*p2=hb-&gt;next,*p3=hc;</span><br><span class="line">    <span class="keyword">while</span>(p1!=ha &amp;&amp; p2!=hb)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(p1-&gt;data==p2-&gt;data)&#123;</span><br><span class="line">            p3-&gt;next=(lnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lnode));</span><br><span class="line">            p3=p3-&gt;next;</span><br><span class="line">            p3-&gt;data=p1-&gt;data;</span><br><span class="line">            p3-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p1-&gt;data&lt;p2-&gt;data)&#123;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ha-&gt;next=hc-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919131501358.png" alt="image-20210919131501358"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date:10-19</span></span><br><span class="line"><span class="comment">//严格单调递增</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">union</span><span class="params">(lnode* &amp;ha, lnode* hb)</span>&#123;</span><br><span class="line">   	lnode* hc=(lnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lnode));</span><br><span class="line">    hc-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    lnode*p1=ha-&gt;next;</span><br><span class="line">    lnode*p2=hb-&gt;next;</span><br><span class="line">    lnode*p3=hc;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1!=ha &amp;&amp; p2!=hb)&#123;</span><br><span class="line">        lnode* p3-&gt;next=(lnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lnode));</span><br><span class="line">        p3=p3-&gt;next;</span><br><span class="line">        p3-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;data&lt;p2-&gt;data)&#123;</span><br><span class="line">            p3-&gt;data=p1-&gt;data;</span><br><span class="line">            p1=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p1-&gt;data&gt;p2-&gt;data)&#123;</span><br><span class="line">            p3-&gt;data=p2-&gt;data;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            p3-&gt;data=p1-&gt;data;</span><br><span class="line">            p1=p-&gt;next;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p1!=ha)&#123;</span><br><span class="line">        lnode* p3-&gt;next=(lnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lnode));</span><br><span class="line">        p3=p3-&gt;next;</span><br><span class="line">        p3-&gt;data=p1-&gt;data;</span><br><span class="line">        p3-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        p1=p1-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p2!=hb)&#123;</span><br><span class="line">        lnode* p3-&gt;next=(lnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lnode));</span><br><span class="line">        p3=p3-&gt;next;</span><br><span class="line">        p3-&gt;data=p2-&gt;data;</span><br><span class="line">        p3-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        p2=p2-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    ha-&gt;next=p3-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2016"><a href="#2016" class="headerlink" title="2016"></a>2016</h2><p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919131534334.png" alt="image-20210919131534334"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date:10-19</span></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">high</span><span class="params">(BTNode* BT)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BT==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l=high(BT-&gt;lt);</span><br><span class="line">    <span class="type">int</span> r=high(BT-&gt;rt);</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)</span><br><span class="line">    	<span class="keyword">return</span> l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> r+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132122394.png" alt="image-20210919132122394"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date:10-20</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertxy</span><span class="params">(Lnode* &amp;head,<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">    Lnode* p=head;</span><br><span class="line">    Lnode* t=(Lnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Lnode));</span><br><span class="line">    t-&gt;data=y;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data!=x)</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            t-&gt;next=p-&gt;next;</span><br><span class="line">            p-&gt;next=t; </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next=t;</span><br><span class="line">    t-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132152938.png" alt="image-20210919132152938"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date:10-20</span></span><br><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rangdelete</span><span class="params">(Lnode* &amp;head,<span class="type">int</span> min,<span class="type">int</span> max)</span>&#123;</span><br><span class="line">    Lnode*p=head;</span><br><span class="line">    Lnode*pre=p;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=head)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data&gt;min &amp;&amp; p-&gt;data&lt;max)&#123;</span><br><span class="line">            pre-&gt;next=p-&gt;next;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pre=pre-&gt;next;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二:利用值非递减，小余写的</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rangdelete</span><span class="params">(Lnode* &amp;head,<span class="type">int</span> min,<span class="type">int</span> max)</span>&#123;</span><br><span class="line">    Lnode*p=head;</span><br><span class="line">    <span class="comment">//找到最后一个值比min小的结点</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=head &amp;&amp; p-&gt;next-&gt;data&lt;=min)</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next==head)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">   	Lnode*p2=p-&gt;next;</span><br><span class="line">    <span class="comment">//找到第一个大于等于max的结点或者是头结点（说明p后面的所有节点值全在min和max之间）</span></span><br><span class="line">    <span class="keyword">while</span>(p2!=head &amp;&amp; p2-&gt;data&lt;max)</span><br><span class="line">        p2=p2-&gt;next;</span><br><span class="line">    p-&gt;next=p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="历年真题算法题整理(3).assets/image-20211020225422525.png" alt="image-20211020225422525" style="zoom: 33%;" />

<h2 id="2015"><a href="#2015" class="headerlink" title="2015"></a>2015</h2><p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132217111.png" alt="image-20210919132217111"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date:10-22</span></span><br><span class="line"><span class="comment">//带头结点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CountA</span><span class="params">(LNode* L,ElemType a)</span>&#123;</span><br><span class="line">    LNode*p=L;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next-&gt;data&gt;a)</span><br><span class="line">            count++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不带头结点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CountA</span><span class="params">(LNode* L,ElemType a)</span>&#123;</span><br><span class="line">    LNode*p=L;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data&gt;a)</span><br><span class="line">            count++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132232059.png" alt="image-20210919132232059"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date:10-22</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">difference</span><span class="params">(Node* heada,Node* headb,<span class="type">int</span> &amp;n)</span>&#123;</span><br><span class="line">    Node*a=heada;</span><br><span class="line">    Node*b=headb;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a-&gt;next!=<span class="literal">NULL</span> &amp;&amp; b-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a-&gt;next-&gt;data&lt;b-&gt;next-&gt;data)&#123;</span><br><span class="line">            a=a-&gt;next;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a-&gt;next-&gt;data&gt;b-&gt;next-&gt;data)</span><br><span class="line">            b=b-&gt;next;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            a-&gt;next=a-&gt;next-&gt;next;</span><br><span class="line">            b=b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        n++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="2014-看王道视频，写代码"><a href="#2014-看王道视频，写代码" class="headerlink" title="2014*看王道视频，写代码"></a>2014*看王道视频，写代码</h2><p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132252975.png" alt="image-20210919132252975"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date:10-26</span></span><br><span class="line"><span class="comment">//第二题</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BTreeNodes</span><span class="params">(Node* p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+BTreeNodes(t-&gt;lchild)+BTreeNodes(p-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小余的代码</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkQueue</span>&#123;</span></span><br><span class="line">    Node*f,*r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队列初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(LinkQueue&amp;que)</span>&#123;</span><br><span class="line">    que.f=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    que.r=que.f;</span><br><span class="line">    que.r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(LinkQueue&amp;que,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    Node*t=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    t-&gt;data=x;</span><br><span class="line">    t-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    que.r-&gt;next=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop</span><span class="params">(LinkQueue&amp;que)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(que.f-&gt;next==<span class="literal">NULL</span>)	<span class="comment">//队列为空</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    que.f-&gt;next=que.f-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(LinkQueue que)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> que.f-&gt;next==<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2013"><a href="#2013" class="headerlink" title="2013"></a>2013</h2><p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132310985.png" alt="image-20210919132310985"></p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">date:<span class="number">10</span><span class="number">-26</span></span><br><span class="line"><span class="comment">//第一题</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Arc</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    Arc*next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    Arc* firstArc;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//数组[]可以不写东西</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertArc</span><span class="params">(Vertex adj[],<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">  	Arc*p=adj[u<span class="number">-1</span>].firstArc;</span><br><span class="line">    Arc*t=(Arc*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Arc));</span><br><span class="line">    t-&gt;key=v;</span><br><span class="line">    t-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">   	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">   	 	adj[u<span class="number">-1</span>].firstArc=t;   </span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        p-&gt;next=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//日期：10-14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 20          <span class="comment">//图的顶点数组的最大长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//边表结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Arc</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="comment">//int len;</span></span><br><span class="line">    Arc* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//顶点结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    Arc* firstArc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addArc</span><span class="params">(Vertex adj[],<span class="type">int</span> u,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">    Arc* p=adj[u<span class="number">-1</span>].firstArc;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//p-&gt;next=(Arc*)malloc(sizeof(Arc));         //@todo 错误！！！</span></span><br><span class="line">        adj[u<span class="number">-1</span>].firstArc=(Arc*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Arc));</span><br><span class="line">        adj[u<span class="number">-1</span>].firstArc-&gt;key=v;</span><br><span class="line">        adj[u<span class="number">-1</span>].firstArc-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        p-&gt;next=(Arc*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Arc));</span><br><span class="line">        p-&gt;next-&gt;key=v;</span><br><span class="line">        p-&gt;next-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date:10-27</span></span><br><span class="line"><span class="comment">//第二题</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">countNode</span><span class="params">(NOde* p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+countNode(p-&gt;lchild)+countNode(p-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2012"><a href="#2012" class="headerlink" title="2012"></a>2012</h2><p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132338490.png" alt="image-20210919132338490"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date:10-27</span></span><br><span class="line"><span class="comment">//假设最大值只有一个</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteMaxNode</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    lnode*p=L;			<span class="comment">//用来遍历</span></span><br><span class="line">    lnode*t=L;			<span class="comment">//用来记录值最大的结点的前驱结点</span></span><br><span class="line">   	<span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next-&gt;data&gt;t-&gt;next-&gt;data)</span><br><span class="line">            t=p;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;next=t-&gt;next-&gt;next;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//假设最大值有很多个</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteMaxNode</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    <span class="comment">//假设链表为空，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    lnode*p=L-&gt;next;</span><br><span class="line">    Elemtype Max=p-&gt;data;</span><br><span class="line">    <span class="comment">//第一轮，找出最大值</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data&gt;Max)</span><br><span class="line">            Max=p-&gt;data;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    lnode*t=L;</span><br><span class="line">    <span class="comment">//第二轮，删除所有data等于max的结点</span></span><br><span class="line">    <span class="keyword">while</span>(t-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;next-&gt;data!=Max)</span><br><span class="line">            t=t-&gt;next;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            t-&gt;next=t-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date：10-27</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(BTreeNode*BT,Elemtype X)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BT==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l=count(BT-&gt;left,X);</span><br><span class="line">    <span class="type">int</span> r=count(BT-&gt;right,X);</span><br><span class="line">    <span class="keyword">if</span>(BT-&gt;data&lt;X)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+l+r;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> l+r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="2009-快速排序"><a href="#2009-快速排序" class="headerlink" title="2009*快速排序"></a>2009*快速排序</h2><p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132405006.png" alt="image-20210919132405006"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date:11-2</span></span><br><span class="line"><span class="comment">//第一题</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;          <span class="comment">//一次划分</span></span><br><span class="line">    <span class="type">int</span> pivot=arr[low];</span><br><span class="line">    <span class="comment">//high右边都是&gt;=pivot的元素</span></span><br><span class="line">    <span class="comment">//low左边都是&lt;pivot的元素</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; arr[high]&gt;=pivot) <span class="comment">//找到第一个小于pivot的元素</span></span><br><span class="line">            high--;</span><br><span class="line">        arr[low]=arr[high];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; arr[low]&lt;pivot)   <span class="comment">//找到第一个大于等于pivot的元素</span></span><br><span class="line">            low++;</span><br><span class="line">        arr[high]=arr[low];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[low]=pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">quickSort2</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="type">int</span> t=partition(arr,low,high);          <span class="comment">//t用来记录基准元素的位置</span></span><br><span class="line">        quickSort2(arr,low,t<span class="number">-1</span>);            <span class="comment">//注意递归调用函数不要调错了</span></span><br><span class="line">        quickSort2(arr,t+<span class="number">1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date:10-28</span></span><br><span class="line">lnode* <span class="title function_">merge</span><span class="params">(lnode* la,lnode* lb)</span>&#123;</span><br><span class="line">    lnode*lc=(lnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lnode));</span><br><span class="line">    lc-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    lnode*p1=la-&gt;next,*p2=lb-&gt;next,*p3=lc;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(p1!=<span class="literal">NULL</span> &amp;&amp; p2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        lnode*t=(lnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lnode));</span><br><span class="line">        t-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;data&lt;=p2-&gt;data)&#123;</span><br><span class="line">            t-&gt;data=p1-&gt;data;</span><br><span class="line">            p3-&gt;next=t;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            t-&gt;data=p2-&gt;data;</span><br><span class="line">            p3-&gt;next=t;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p3=p3-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p1!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        lnode*t=(lnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lnode));</span><br><span class="line">       	t-&gt;data=p1-&gt;data;</span><br><span class="line">        t-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        p3-&gt;next=t;</span><br><span class="line">        p3=p3-&gt;next;   </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">while</span>(p2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        lnode*t=(lnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lnode));</span><br><span class="line">       	t-&gt;data=p2-&gt;data;</span><br><span class="line">        t-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        p3-&gt;next=t;</span><br><span class="line">        p3=p3-&gt;next;   </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> lc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2007"><a href="#2007" class="headerlink" title="2007"></a>2007</h2><p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132443745.png" alt="image-20210919132443745"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date:10-29</span></span><br><span class="line"><span class="comment">//第二题</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Arc</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    Arc* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="comment">//int len;</span></span><br><span class="line">    Arc*firstNode;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DelArc</span><span class="params">(Vertex adj[],<span class="type">int</span> u,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">    Arc*p=adj[u<span class="number">-1</span>].firstArc;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;key==v)&#123;</span><br><span class="line">        adj[u<span class="number">-1</span>].firstArc=p-&gt;next;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next-&gt;key!=v)</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    p-&gt;next=p-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date:10-28</span></span><br><span class="line"><span class="comment">//第一题</span></span><br><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(Node* &amp;tree,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    Node*p=tree;</span><br><span class="line">    Node*t=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    t-&gt;data=x;</span><br><span class="line">    t-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        tree=t;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data&lt;x &amp;&amp; p-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;data&gt;x &amp;&amp; p-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;data&lt;x &amp;&amp; p-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//插入</span></span><br><span class="line">            p-&gt;rchild=t;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//插入</span></span><br><span class="line">            p-&gt;lchild=t;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归方法二：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(Node* &amp;tree,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    Node*p=tree;</span><br><span class="line">    Node*pre=<span class="literal">NULL</span>;</span><br><span class="line">    Node*t=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    t-&gt;data=x;</span><br><span class="line">    t-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">if</span>(tree==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        tree=t;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        pre=p;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data&lt;x)</span><br><span class="line">           	p=p-&gt;rchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p=p-&gt;lchild;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre-&gt;data&lt;x)</span><br><span class="line">        pre-&gt;rchild=t;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pre-&gt;lchild=t;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(Node* &amp;tree,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        tree=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        tree-&gt;data=x;</span><br><span class="line">        tree-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">        tree-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if(tree-&gt;data&lt;x &amp;&amp; tree-&gt;rchild==NULL)&#123;</span></span><br><span class="line"><span class="comment">        tree-&gt;rchild=(Node*)malloc(sizeof(Node));</span></span><br><span class="line"><span class="comment">        Node*t=tree-&gt;rchild</span></span><br><span class="line"><span class="comment">        t-&gt;data=x;</span></span><br><span class="line"><span class="comment">        t-&gt;lchild=NULL;</span></span><br><span class="line"><span class="comment">        t-&gt;rchild=NULL;</span></span><br><span class="line"><span class="comment">        return;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    if(tree-&gt;data&gt;x &amp;&amp; tree-&gt;lchild==NULL)&#123;</span></span><br><span class="line"><span class="comment">        tree-&gt;lchild=(Node*)malloc(sizeof(Node));</span></span><br><span class="line"><span class="comment">        Node*t=tree-&gt;lchild</span></span><br><span class="line"><span class="comment">        t-&gt;data=x;</span></span><br><span class="line"><span class="comment">        t-&gt;lchild=NULL;</span></span><br><span class="line"><span class="comment">        t-&gt;rchild=NULL;</span></span><br><span class="line"><span class="comment">        return;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">if</span>(tree-&gt;data&lt;x)</span><br><span class="line">    	insert(tree-&gt;rchild,x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        insert(tree-&gt;lchild,x);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132501471.png" alt="image-20210919132501471"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date:10-29</span></span><br><span class="line"><span class="comment">//第一题</span></span><br><span class="line"><span class="comment">//把s复制到d上</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">treecopy</span><span class="params">(Node* &amp;d,Node* s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        d=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*if(s-&gt;lchild==NULL &amp;&amp; s-&gt;rchild==NULL)&#123;</span></span><br><span class="line"><span class="comment">        d=(Node*)malloc(sizeof(Node));</span></span><br><span class="line"><span class="comment">        d-&gt;data=s-&gt;data;</span></span><br><span class="line"><span class="comment">        return;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    d=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    d-&gt;data=s-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> treecopy(d-&gt;lchild,s-&gt;lchild) &amp;&amp; treecopy(d-&gt;rchild,s-&gt;rchild);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date:10-29</span></span><br><span class="line"><span class="comment">//第二题</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Convert</span><span class="params">(<span class="type">int</span> r[],Node* la,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Node*t=la;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        Node*p=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        p-&gt;data=r[i];</span><br><span class="line">        p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;prior=t;</span><br><span class="line">        t-&gt;next=p;</span><br><span class="line">        t=t-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="注意递归过程"><a href="#注意递归过程" class="headerlink" title="注意递归过程"></a>注意递归过程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date:10-30</span></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Convert</span><span class="params">(<span class="type">int</span> r[],Node* la,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    la-&gt;next=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    la-&gt;next-&gt;prior=la;</span><br><span class="line">    la-&gt;next-&gt;data=r[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    Convert(r+<span class="number">1</span>,la-&gt;next,n<span class="number">-1</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2006"><a href="#2006" class="headerlink" title="2006"></a>2006</h2><p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132523831.png" alt="image-20210919132523831"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date:10-29</span></span><br><span class="line"><span class="comment">//第一题</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">treeleaf</span><span class="params">(Node* p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//下面这个终止条件忘了写了</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild==<span class="literal">NULL</span> &amp;&amp; p-&gt;rchild==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> l=treeleaf(p-&gt;lchild);</span><br><span class="line">    <span class="type">int</span> r=treeleaf(p-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> l+r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date:10-29</span></span><br><span class="line"><span class="comment">//第二题</span></span><br><span class="line"><span class="type">int</span> outdegree[N];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">finddegree</span><span class="params">(Vertex adj[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        Arc*p=adj[i].firstArc;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">            outdegree[i]=<span class="number">0</span>;</span><br><span class="line">       	<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            adj[i]=count;</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132535659.png" alt="image-20210919132535659"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date:10-29</span></span><br><span class="line"><span class="comment">//第一题</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exchange</span><span class="params">(Node* root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Node*tmp=root-&gt;lchild;</span><br><span class="line">    root-&gt;lchild=root-&gt;rchild;</span><br><span class="line">    root-&gt;rchild=tmp; </span><br><span class="line">    </span><br><span class="line">    exchange(root-&gt;lchild);</span><br><span class="line">    exchange(root-&gt;rchild);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="注意两个if的条件"><a href="#注意两个if的条件" class="headerlink" title="注意两个if的条件"></a>注意两个if的条件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date:10-29</span></span><br><span class="line"><span class="comment">//第二题</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delMinMax</span><span class="params">(DLnode* head,<span class="type">int</span> min,<span class="type">int</span> max)</span>&#123;</span><br><span class="line">    DLnode*p=head;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span> &amp;&amp; p-&gt;next-&gt;data&lt;=min)			<span class="comment">//要&lt;=min,不能是&lt;min</span></span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    DLnode*p1=p;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next-&gt;data&lt;max &amp;&amp; p-&gt;next!=<span class="literal">NULL</span>)			<span class="comment">//只能是&lt;max,不能&lt;=max</span></span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面写麻烦了，可以删去</span></span><br><span class="line">    <span class="comment">/*if(p-&gt;next==NULL)&#123;</span></span><br><span class="line"><span class="comment">        p1-&gt;next=NULL;</span></span><br><span class="line"><span class="comment">        return;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    </span><br><span class="line">    p1-&gt;next=p-&gt;next;</span><br><span class="line">    p1-&gt;next-&gt;pre=p1;      </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date:10-30</span></span><br><span class="line"><span class="comment">//第二题，递归</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delMinMax</span><span class="params">(DLnode* head,<span class="type">int</span> min,<span class="type">int</span> max)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next-&gt;data&gt;min &amp;&amp; head-&gt;next-&gt;data&lt;max)&#123;</span><br><span class="line">        head-&gt;next=head-&gt;next-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;next-&gt;pre=head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    deMinMax(head-&gt;next,min,max);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2003"><a href="#2003" class="headerlink" title="2003"></a>2003</h2><p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210919132550472.png" alt="image-20210919132550472"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date:10-27</span></span><br><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">countEven</span><span class="params">(Node* H)</span>&#123;</span><br><span class="line">    Node*p=H;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            count++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">countEven</span><span class="params">(Node* H)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(H==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(H-&gt;data%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+countEven(H-&gt;next);</span><br><span class="line">  	<span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> countEven(H-&gt;next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="常考题型总结"><a href="#常考题型总结" class="headerlink" title="常考题型总结"></a>常考题型总结</h1><ol>
<li><p>链表</p>
<ul>
<li>单链表</li>
<li>循环链表</li>
</ul>
</li>
<li><p>顺序表</p>
</li>
<li><p>二叉树</p>
<ul>
<li><p>递归</p>
</li>
<li><p>非递归方法</p>
</li>
</ul>
</li>
<li><p>图</p>
<ul>
<li>dfs</li>
<li>bfs</li>
<li>邻接表</li>
<li>邻接矩阵</li>
</ul>
</li>
</ol>
<h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><p>完成leetcode中所有关于链表、图、二叉树、顺序表的简单题，每天至少一题，链接地址如下</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/tag/linked-list/problemset/">链表简单题合集</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/tag/binary-tree/problemset/">二叉树简单题合集</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/tag/graph/problemset/">图的简单题合集</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/tag/recursion/problemset/">递归简单题合集</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/tag/array/problemset/">数组简单题合集</a>，题目较多，小余挑一些给你写</p>
<h1 id="往年真题补充"><a href="#往年真题补充" class="headerlink" title="往年真题补充"></a>往年真题补充</h1><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p><img src="/%E5%8E%86%E5%B9%B4%E7%9C%9F%E9%A2%98%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86(3).assets/image-20211106155656300.png" alt="image-20211106155656300"></p>
<h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p><img src="/%E5%8E%86%E5%B9%B4%E7%9C%9F%E9%A2%98%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86(3).assets/image-20211106155714089.png" alt="image-20211106155714089"></p>
<h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p><img src="/%E5%8E%86%E5%B9%B4%E7%9C%9F%E9%A2%98%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86(3).assets/image-20211106155727852.png" alt="image-20211106155727852"></p>
<h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p><img src="/%E5%8E%86%E5%B9%B4%E7%9C%9F%E9%A2%98%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86(3).assets/image-20211106155748548.png" alt="image-20211106155748548"></p>
<h2 id="五"><a href="#五" class="headerlink" title="五"></a>五</h2><p><img src="/%E5%8E%86%E5%B9%B4%E7%9C%9F%E9%A2%98%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86(3).assets/image-20211106155802023.png" alt="image-20211106155802023"></p>
<h2 id="六"><a href="#六" class="headerlink" title="六"></a>六</h2><p><img src="/%E5%8E%86%E5%B9%B4%E7%9C%9F%E9%A2%98%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86(3).assets/image-20211106155816682.png" alt="image-20211106155816682"></p>
<h2 id="七"><a href="#七" class="headerlink" title="七"></a>七</h2><p><img src="/%E5%8E%86%E5%B9%B4%E7%9C%9F%E9%A2%98%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86(3).assets/image-20211106155826168.png" alt="image-20211106155826168"> </p>
</div><div class="article-licensing box"><div class="licensing-title"><p>南理工877历年初试真题</p><p><a href="http://example.com/2022/04/27/算法/南理工877历年初试真题/">http://example.com/2022/04/27/算法/南理工877历年初试真题/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>John Doe</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2022-04-27</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-04-27</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/04/28/%E7%AE%97%E6%B3%95/leetcode-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">反转链表</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/04/27/%E7%AE%97%E6%B3%95/leetcode-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"><span class="level-item">无重复字符的最长子串</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/icon.jpg" alt="陈香玉"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">陈香玉</p><p class="is-size-6 is-block">下个路口见</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">9</p></a></div></div></nav></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/leetcode/"><span class="level-start"><span class="level-item">leetcode</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%9A%8F%E7%AC%94/"><span class="level-start"><span class="level-item">随笔</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-28T13:49:07.690Z">2022-04-28</time></p><p class="title"><a href="/2022/04/28/%E7%AE%97%E6%B3%95/leetcode-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/">只出现一次的数字</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-28T13:49:06.484Z">2022-04-28</time></p><p class="title"><a href="/2022/04/28/%E7%AE%97%E6%B3%95/leetcode-2%E7%9A%84%E5%B9%82/">2的幂</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-28T12:56:57.585Z">2022-04-28</time></p><p class="title"><a href="/2022/04/28/%E7%AE%97%E6%B3%95/leetcode-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/">反转链表</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-27T09:07:19.638Z">2022-04-27</time></p><p class="title"><a href="/2022/04/27/%E7%AE%97%E6%B3%95/%E5%8D%97%E7%90%86%E5%B7%A5877%E5%8E%86%E5%B9%B4%E5%88%9D%E8%AF%95%E7%9C%9F%E9%A2%98/">南理工877历年初试真题</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-27T08:57:39.807Z">2022-04-27</time></p><p class="title"><a href="/2022/04/27/%E7%AE%97%E6%B3%95/leetcode-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/">无重复字符的最长子串</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/leetcode/"><span class="tag">leetcode</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"><span class="tag">二分搜索</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"><span class="tag">位运算</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"><span class="tag">前缀和与差分</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"><span class="tag">单调栈</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/"><span class="tag">异或运算</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"><span class="tag">快慢指针</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"><span class="tag">滑动窗口</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a><p class="is-size-7"><span>&copy; 2022 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>